{
  "address": "0x9c9dd01E65E0285dc9FDfb470347A39Be4a14399",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_flow",
          "type": "address"
        },
        {
          "internalType": "bytes32",
          "name": "_merkleRoot",
          "type": "bytes32"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "to",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "Claim",
      "type": "event"
    },
    {
      "inputs": [],
      "name": "FLOW",
      "outputs": [
        {
          "internalType": "contract IFlow",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "to",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        },
        {
          "internalType": "bytes32[]",
          "name": "proof",
          "type": "bytes32[]"
        }
      ],
      "name": "claim",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "name": "hasClaimed",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "merkleRoot",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0x80ebb09af24a530b8e63e87c518de1fa19da091dacaf99f09a47f021d87871d8",
  "receipt": {
    "to": null,
    "from": "0x53f3B51FD7F327E1Ec4E6eAa3A049149cB2acaD2",
    "contractAddress": "0x9c9dd01E65E0285dc9FDfb470347A39Be4a14399",
    "transactionIndex": 1,
    "gasUsed": "356966",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0xc8ad8914a7ac3b25b8aab87c1c4b5215c7f44d4eaac39ffaab0096072a43f405",
    "transactionHash": "0x80ebb09af24a530b8e63e87c518de1fa19da091dacaf99f09a47f021d87871d8",
    "logs": [],
    "blockNumber": 6188491,
    "cumulativeGasUsed": "356966",
    "status": 1,
    "byzantium": true
  },
  "args": [
    "0x49E4eA802DdF4CAF7C699782a80DeefdC03Dcb4B",
    "0xbb99a09fb3b8499385659e82a8da93596dd07082fe86981ec06c83181dee489f"
  ],
  "numDeployments": 2,
  "solcInputHash": "6e27611a2cedd773c4cc6e46935e6392",
  "metadata": "{\"compiler\":{\"version\":\"0.8.13+commit.abaa5c0e\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_flow\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"_merkleRoot\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Claim\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"FLOW\",\"outputs\":[{\"internalType\":\"contract IFlow\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"proof\",\"type\":\"bytes32[]\"}],\"name\":\"claim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"hasClaimed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"merkleRoot\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"author\":\"Modified from Merkle Airdrop Starter (https://github.com/Anish-Agnihotri/merkle-airdrop-starter/blob/master/contracts/src/MerkleClaimERC20.sol)\",\"events\":{\"Claim(address,uint256)\":{\"params\":{\"amount\":\"of tokens claimed\",\"to\":\"recipient of claim\"}}},\"kind\":\"dev\",\"methods\":{\"claim(address,uint256,bytes32[])\":{\"params\":{\"amount\":\"of tokens owed to claimee\",\"proof\":\"merkle proof to prove address and amount are in tree\",\"to\":\"address of claimee\"}},\"constructor\":{\"params\":{\"_flow\":\"address\",\"_merkleRoot\":\"of claimees\"}}},\"title\":\"MerkleClaim\",\"version\":1},\"userdoc\":{\"events\":{\"Claim(address,uint256)\":{\"notice\":\"Emitted after a successful token claim\"}},\"kind\":\"user\",\"methods\":{\"FLOW()\":{\"notice\":\"FLOW token to claim\"},\"claim(address,uint256,bytes32[])\":{\"notice\":\"Allows claiming tokens if address is part of merkle tree\"},\"constructor\":{\"notice\":\"Creates a new MerkleClaim contract\"},\"hasClaimed(address)\":{\"notice\":\"Mapping of addresses who have claimed tokens\"},\"merkleRoot()\":{\"notice\":\"ERC20-claimee inclusion root\"}},\"notice\":\"Claims FLOW for members of a merkle tree\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/redeem/MerkleClaim.sol\":\"MerkleClaim\"},\"evmVersion\":\"london\",\"libraries\":{\":__CACHE_BREAKER__\":\"0x0000000000000031363735303535373437363232\"},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"contracts/interfaces/IFlow.sol\":{\"content\":\"pragma solidity 0.8.13;\\n\\ninterface IFlow {\\n    function totalSupply() external view returns (uint);\\n    function balanceOf(address) external view returns (uint);\\n    function approve(address spender, uint value) external returns (bool);\\n    function transfer(address, uint) external returns (bool);\\n    function transferFrom(address,address,uint) external returns (bool);\\n    function mint(address, uint) external returns (bool);\\n    function minter() external returns (address);\\n    function claim(address, uint) external returns (bool);\\n}\\n\",\"keccak256\":\"0x957c4997b5ac464df3484317f7526b8425008684147ab08af5e4bd10d5a60d8d\"},\"contracts/redeem/MerkleClaim.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity 0.8.13;\\n\\n/// ============ Imports ============\\n\\nimport {IFlow} from \\\"contracts/interfaces/IFlow.sol\\\";\\nimport {MerkleProof} from \\\"lib/openzeppelin-contracts/contracts/utils/cryptography/MerkleProof.sol\\\"; // OZ: MerkleProof\\n\\n/// @title MerkleClaim\\n/// @notice Claims FLOW for members of a merkle tree\\n/// @author Modified from Merkle Airdrop Starter (https://github.com/Anish-Agnihotri/merkle-airdrop-starter/blob/master/contracts/src/MerkleClaimERC20.sol)\\ncontract MerkleClaim {\\n    /// ============ Immutable storage ============\\n\\n    /// @notice FLOW token to claim\\n    IFlow public immutable FLOW;\\n    /// @notice ERC20-claimee inclusion root\\n    bytes32 public immutable merkleRoot;\\n\\n    /// ============ Mutable storage ============\\n\\n    /// @notice Mapping of addresses who have claimed tokens\\n    mapping(address => bool) public hasClaimed;\\n\\n    /// ============ Constructor ============\\n\\n    /// @notice Creates a new MerkleClaim contract\\n    /// @param _flow address\\n    /// @param _merkleRoot of claimees\\n    constructor(address _flow, bytes32 _merkleRoot) {\\n        FLOW = IFlow(_flow);\\n        merkleRoot = _merkleRoot;\\n    }\\n\\n    /// ============ Events ============\\n\\n    /// @notice Emitted after a successful token claim\\n    /// @param to recipient of claim\\n    /// @param amount of tokens claimed\\n    event Claim(address indexed to, uint256 amount);\\n\\n    /// ============ Functions ============\\n\\n    /// @notice Allows claiming tokens if address is part of merkle tree\\n    /// @param to address of claimee\\n    /// @param amount of tokens owed to claimee\\n    /// @param proof merkle proof to prove address and amount are in tree\\n    function claim(\\n        address to,\\n        uint256 amount,\\n        bytes32[] calldata proof\\n    ) external {\\n        // Throw if address has already claimed tokens\\n        require(!hasClaimed[to], \\\"ALREADY_CLAIMED\\\");\\n\\n        // Verify merkle proof, or revert if not in tree\\n        bytes32 leaf = keccak256(abi.encodePacked(to, amount));\\n        bool isValidLeaf = MerkleProof.verify(proof, merkleRoot, leaf);\\n        require(isValidLeaf, \\\"NOT_IN_MERKLE\\\");\\n\\n        // Set address to claimed\\n        hasClaimed[to] = true;\\n\\n        // Claim tokens for address\\n        require(FLOW.claim(to, amount), \\\"CLAIM_FAILED\\\");\\n\\n        // Emit claim event\\n        emit Claim(to, amount);\\n    }\\n}\\n\",\"keccak256\":\"0xf169ba9559c5c39dc79b2281410b09fd92f200a3b0489b32e28ce08a00a98826\",\"license\":\"AGPL-3.0-only\"},\"lib/openzeppelin-contracts/contracts/utils/cryptography/MerkleProof.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/cryptography/MerkleProof.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev These functions deal with verification of Merkle Tree proofs.\\n *\\n * The tree and the proofs can be generated using our\\n * https://github.com/OpenZeppelin/merkle-tree[JavaScript library].\\n * You will find a quickstart guide in the readme.\\n *\\n * WARNING: You should avoid using leaf values that are 64 bytes long prior to\\n * hashing, or use a hash function other than keccak256 for hashing leaves.\\n * This is because the concatenation of a sorted pair of internal nodes in\\n * the merkle tree could be reinterpreted as a leaf value.\\n * OpenZeppelin's JavaScript library generates merkle trees that are safe\\n * against this attack out of the box.\\n */\\nlibrary MerkleProof {\\n    /**\\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\\n     * defined by `root`. For this, a `proof` must be provided, containing\\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\\n     */\\n    function verify(bytes32[] memory proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\\n        return processProof(proof, leaf) == root;\\n    }\\n\\n    /**\\n     * @dev Calldata version of {verify}\\n     *\\n     * _Available since v4.7._\\n     */\\n    function verifyCalldata(bytes32[] calldata proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\\n        return processProofCalldata(proof, leaf) == root;\\n    }\\n\\n    /**\\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\\n     * hash matches the root of the tree. When processing the proof, the pairs\\n     * of leafs & pre-images are assumed to be sorted.\\n     *\\n     * _Available since v4.4._\\n     */\\n    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\\n        bytes32 computedHash = leaf;\\n        for (uint256 i = 0; i < proof.length; i++) {\\n            computedHash = _hashPair(computedHash, proof[i]);\\n        }\\n        return computedHash;\\n    }\\n\\n    /**\\n     * @dev Calldata version of {processProof}\\n     *\\n     * _Available since v4.7._\\n     */\\n    function processProofCalldata(bytes32[] calldata proof, bytes32 leaf) internal pure returns (bytes32) {\\n        bytes32 computedHash = leaf;\\n        for (uint256 i = 0; i < proof.length; i++) {\\n            computedHash = _hashPair(computedHash, proof[i]);\\n        }\\n        return computedHash;\\n    }\\n\\n    /**\\n     * @dev Returns true if the `leaves` can be simultaneously proven to be a part of a merkle tree defined by\\n     * `root`, according to `proof` and `proofFlags` as described in {processMultiProof}.\\n     *\\n     * CAUTION: Not all merkle trees admit multiproofs. See {processMultiProof} for details.\\n     *\\n     * _Available since v4.7._\\n     */\\n    function multiProofVerify(\\n        bytes32[] memory proof,\\n        bool[] memory proofFlags,\\n        bytes32 root,\\n        bytes32[] memory leaves\\n    ) internal pure returns (bool) {\\n        return processMultiProof(proof, proofFlags, leaves) == root;\\n    }\\n\\n    /**\\n     * @dev Calldata version of {multiProofVerify}\\n     *\\n     * CAUTION: Not all merkle trees admit multiproofs. See {processMultiProof} for details.\\n     *\\n     * _Available since v4.7._\\n     */\\n    function multiProofVerifyCalldata(\\n        bytes32[] calldata proof,\\n        bool[] calldata proofFlags,\\n        bytes32 root,\\n        bytes32[] memory leaves\\n    ) internal pure returns (bool) {\\n        return processMultiProofCalldata(proof, proofFlags, leaves) == root;\\n    }\\n\\n    /**\\n     * @dev Returns the root of a tree reconstructed from `leaves` and sibling nodes in `proof`. The reconstruction\\n     * proceeds by incrementally reconstructing all inner nodes by combining a leaf/inner node with either another\\n     * leaf/inner node or a proof sibling node, depending on whether each `proofFlags` item is true or false\\n     * respectively.\\n     *\\n     * CAUTION: Not all merkle trees admit multiproofs. To use multiproofs, it is sufficient to ensure that: 1) the tree\\n     * is complete (but not necessarily perfect), 2) the leaves to be proven are in the opposite order they are in the\\n     * tree (i.e., as seen from right to left starting at the deepest layer and continuing at the next layer).\\n     *\\n     * _Available since v4.7._\\n     */\\n    function processMultiProof(\\n        bytes32[] memory proof,\\n        bool[] memory proofFlags,\\n        bytes32[] memory leaves\\n    ) internal pure returns (bytes32 merkleRoot) {\\n        // This function rebuilds the root hash by traversing the tree up from the leaves. The root is rebuilt by\\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\\n        // the merkle tree.\\n        uint256 leavesLen = leaves.length;\\n        uint256 totalHashes = proofFlags.length;\\n\\n        // Check proof validity.\\n        require(leavesLen + proof.length - 1 == totalHashes, \\\"MerkleProof: invalid multiproof\\\");\\n\\n        // The xxxPos values are \\\"pointers\\\" to the next value to consume in each array. All accesses are done using\\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \\\"pop\\\".\\n        bytes32[] memory hashes = new bytes32[](totalHashes);\\n        uint256 leafPos = 0;\\n        uint256 hashPos = 0;\\n        uint256 proofPos = 0;\\n        // At each step, we compute the next hash using two values:\\n        // - a value from the \\\"main queue\\\". If not all leaves have been consumed, we get the next leaf, otherwise we\\n        //   get the next hash.\\n        // - depending on the flag, either another value from the \\\"main queue\\\" (merging branches) or an element from the\\n        //   `proof` array.\\n        for (uint256 i = 0; i < totalHashes; i++) {\\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\\n            bytes32 b = proofFlags[i]\\n                ? (leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++])\\n                : proof[proofPos++];\\n            hashes[i] = _hashPair(a, b);\\n        }\\n\\n        if (totalHashes > 0) {\\n            unchecked {\\n                return hashes[totalHashes - 1];\\n            }\\n        } else if (leavesLen > 0) {\\n            return leaves[0];\\n        } else {\\n            return proof[0];\\n        }\\n    }\\n\\n    /**\\n     * @dev Calldata version of {processMultiProof}.\\n     *\\n     * CAUTION: Not all merkle trees admit multiproofs. See {processMultiProof} for details.\\n     *\\n     * _Available since v4.7._\\n     */\\n    function processMultiProofCalldata(\\n        bytes32[] calldata proof,\\n        bool[] calldata proofFlags,\\n        bytes32[] memory leaves\\n    ) internal pure returns (bytes32 merkleRoot) {\\n        // This function rebuilds the root hash by traversing the tree up from the leaves. The root is rebuilt by\\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\\n        // the merkle tree.\\n        uint256 leavesLen = leaves.length;\\n        uint256 totalHashes = proofFlags.length;\\n\\n        // Check proof validity.\\n        require(leavesLen + proof.length - 1 == totalHashes, \\\"MerkleProof: invalid multiproof\\\");\\n\\n        // The xxxPos values are \\\"pointers\\\" to the next value to consume in each array. All accesses are done using\\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \\\"pop\\\".\\n        bytes32[] memory hashes = new bytes32[](totalHashes);\\n        uint256 leafPos = 0;\\n        uint256 hashPos = 0;\\n        uint256 proofPos = 0;\\n        // At each step, we compute the next hash using two values:\\n        // - a value from the \\\"main queue\\\". If not all leaves have been consumed, we get the next leaf, otherwise we\\n        //   get the next hash.\\n        // - depending on the flag, either another value from the \\\"main queue\\\" (merging branches) or an element from the\\n        //   `proof` array.\\n        for (uint256 i = 0; i < totalHashes; i++) {\\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\\n            bytes32 b = proofFlags[i]\\n                ? (leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++])\\n                : proof[proofPos++];\\n            hashes[i] = _hashPair(a, b);\\n        }\\n\\n        if (totalHashes > 0) {\\n            unchecked {\\n                return hashes[totalHashes - 1];\\n            }\\n        } else if (leavesLen > 0) {\\n            return leaves[0];\\n        } else {\\n            return proof[0];\\n        }\\n    }\\n\\n    function _hashPair(bytes32 a, bytes32 b) private pure returns (bytes32) {\\n        return a < b ? _efficientHash(a, b) : _efficientHash(b, a);\\n    }\\n\\n    function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, a)\\n            mstore(0x20, b)\\n            value := keccak256(0x00, 0x40)\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xcc76dbe53154a5bbd12fdd1613a73f73f3dc7c63d813be36f7ee606f52d6a7b3\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x60c060405234801561001057600080fd5b5060405161062638038061062683398101604081905261002f91610045565b6001600160a01b0390911660805260a05261007f565b6000806040838503121561005857600080fd5b82516001600160a01b038116811461006f57600080fd5b6020939093015192949293505050565b60805160a0516105766100b060003960008181605601526101ea0152600081816090015261029601526105766000f3fe608060405234801561001057600080fd5b506004361061004c5760003560e01c80632eb4a7ab146100515780633189097b1461008b5780633d13f874146100ca57806373b2e80e146100df575b600080fd5b6100787f000000000000000000000000000000000000000000000000000000000000000081565b6040519081526020015b60405180910390f35b6100b27f000000000000000000000000000000000000000000000000000000000000000081565b6040516001600160a01b039091168152602001610082565b6100dd6100d836600461043c565b610112565b005b6101026100ed3660046104c6565b60006020819052908152604090205460ff1681565b6040519015158152602001610082565b6001600160a01b03841660009081526020819052604090205460ff16156101725760405162461bcd60e51b815260206004820152600f60248201526e1053149150511657d0d31052535151608a1b60448201526064015b60405180910390fd5b6040516bffffffffffffffffffffffff19606086901b1660208201526034810184905260009060540160405160208183030381529060405280519060200120905060006102158484808060200260200160405190810160405280939291908181526020018383602002808284376000920191909152507f0000000000000000000000000000000000000000000000000000000000000000925086915061038b9050565b9050806102545760405162461bcd60e51b815260206004820152600d60248201526c4e4f545f494e5f4d45524b4c4560981b6044820152606401610169565b6001600160a01b0386811660008181526020819052604090819020805460ff1916600117905551635569f64b60e11b81526004810191909152602481018790527f00000000000000000000000000000000000000000000000000000000000000009091169063aad3ec96906044016020604051808303816000875af11580156102e1573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061030591906104e1565b6103405760405162461bcd60e51b815260206004820152600c60248201526b10d310525357d1905253115160a21b6044820152606401610169565b856001600160a01b03167f47cee97cb7acd717b3c0aa1435d004cd5b3c8c57d70dbceb4e4458bbd60e39d48660405161037b91815260200190565b60405180910390a2505050505050565b60008261039885846103a1565b14949350505050565b600081815b84518110156103e6576103d2828683815181106103c5576103c5610503565b60200260200101516103ee565b9150806103de81610519565b9150506103a6565b509392505050565b600081831061040a576000828152602084905260409020610419565b60008381526020839052604090205b9392505050565b80356001600160a01b038116811461043757600080fd5b919050565b6000806000806060858703121561045257600080fd5b61045b85610420565b935060208501359250604085013567ffffffffffffffff8082111561047f57600080fd5b818701915087601f83011261049357600080fd5b8135818111156104a257600080fd5b8860208260051b85010111156104b757600080fd5b95989497505060200194505050565b6000602082840312156104d857600080fd5b61041982610420565b6000602082840312156104f357600080fd5b8151801515811461041957600080fd5b634e487b7160e01b600052603260045260246000fd5b60006001820161053957634e487b7160e01b600052601160045260246000fd5b506001019056fea2646970667358221220323b4f0f7408a55f89cbb1bd411dd05b1199a87593d6ffceef2cb6fc02b0efa364736f6c634300080d0033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b506004361061004c5760003560e01c80632eb4a7ab146100515780633189097b1461008b5780633d13f874146100ca57806373b2e80e146100df575b600080fd5b6100787f000000000000000000000000000000000000000000000000000000000000000081565b6040519081526020015b60405180910390f35b6100b27f000000000000000000000000000000000000000000000000000000000000000081565b6040516001600160a01b039091168152602001610082565b6100dd6100d836600461043c565b610112565b005b6101026100ed3660046104c6565b60006020819052908152604090205460ff1681565b6040519015158152602001610082565b6001600160a01b03841660009081526020819052604090205460ff16156101725760405162461bcd60e51b815260206004820152600f60248201526e1053149150511657d0d31052535151608a1b60448201526064015b60405180910390fd5b6040516bffffffffffffffffffffffff19606086901b1660208201526034810184905260009060540160405160208183030381529060405280519060200120905060006102158484808060200260200160405190810160405280939291908181526020018383602002808284376000920191909152507f0000000000000000000000000000000000000000000000000000000000000000925086915061038b9050565b9050806102545760405162461bcd60e51b815260206004820152600d60248201526c4e4f545f494e5f4d45524b4c4560981b6044820152606401610169565b6001600160a01b0386811660008181526020819052604090819020805460ff1916600117905551635569f64b60e11b81526004810191909152602481018790527f00000000000000000000000000000000000000000000000000000000000000009091169063aad3ec96906044016020604051808303816000875af11580156102e1573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061030591906104e1565b6103405760405162461bcd60e51b815260206004820152600c60248201526b10d310525357d1905253115160a21b6044820152606401610169565b856001600160a01b03167f47cee97cb7acd717b3c0aa1435d004cd5b3c8c57d70dbceb4e4458bbd60e39d48660405161037b91815260200190565b60405180910390a2505050505050565b60008261039885846103a1565b14949350505050565b600081815b84518110156103e6576103d2828683815181106103c5576103c5610503565b60200260200101516103ee565b9150806103de81610519565b9150506103a6565b509392505050565b600081831061040a576000828152602084905260409020610419565b60008381526020839052604090205b9392505050565b80356001600160a01b038116811461043757600080fd5b919050565b6000806000806060858703121561045257600080fd5b61045b85610420565b935060208501359250604085013567ffffffffffffffff8082111561047f57600080fd5b818701915087601f83011261049357600080fd5b8135818111156104a257600080fd5b8860208260051b85010111156104b757600080fd5b95989497505060200194505050565b6000602082840312156104d857600080fd5b61041982610420565b6000602082840312156104f357600080fd5b8151801515811461041957600080fd5b634e487b7160e01b600052603260045260246000fd5b60006001820161053957634e487b7160e01b600052601160045260246000fd5b506001019056fea2646970667358221220323b4f0f7408a55f89cbb1bd411dd05b1199a87593d6ffceef2cb6fc02b0efa364736f6c634300080d0033",
  "devdoc": {
    "author": "Modified from Merkle Airdrop Starter (https://github.com/Anish-Agnihotri/merkle-airdrop-starter/blob/master/contracts/src/MerkleClaimERC20.sol)",
    "events": {
      "Claim(address,uint256)": {
        "params": {
          "amount": "of tokens claimed",
          "to": "recipient of claim"
        }
      }
    },
    "kind": "dev",
    "methods": {
      "claim(address,uint256,bytes32[])": {
        "params": {
          "amount": "of tokens owed to claimee",
          "proof": "merkle proof to prove address and amount are in tree",
          "to": "address of claimee"
        }
      },
      "constructor": {
        "params": {
          "_flow": "address",
          "_merkleRoot": "of claimees"
        }
      }
    },
    "title": "MerkleClaim",
    "version": 1
  },
  "userdoc": {
    "events": {
      "Claim(address,uint256)": {
        "notice": "Emitted after a successful token claim"
      }
    },
    "kind": "user",
    "methods": {
      "FLOW()": {
        "notice": "FLOW token to claim"
      },
      "claim(address,uint256,bytes32[])": {
        "notice": "Allows claiming tokens if address is part of merkle tree"
      },
      "constructor": {
        "notice": "Creates a new MerkleClaim contract"
      },
      "hasClaimed(address)": {
        "notice": "Mapping of addresses who have claimed tokens"
      },
      "merkleRoot()": {
        "notice": "ERC20-claimee inclusion root"
      }
    },
    "notice": "Claims FLOW for members of a merkle tree",
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 24474,
        "contract": "contracts/redeem/MerkleClaim.sol:MerkleClaim",
        "label": "hasClaimed",
        "offset": 0,
        "slot": "0",
        "type": "t_mapping(t_address,t_bool)"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_bool": {
        "encoding": "inplace",
        "label": "bool",
        "numberOfBytes": "1"
      },
      "t_mapping(t_address,t_bool)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => bool)",
        "numberOfBytes": "32",
        "value": "t_bool"
      }
    }
  }
}