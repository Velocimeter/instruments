{
  "address": "0xF32608868E215FC3164FDe378dca8D3741d0430A",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_velo",
          "type": "address"
        },
        {
          "internalType": "bytes32",
          "name": "_merkleRoot",
          "type": "bytes32"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "to",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "Claim",
      "type": "event"
    },
    {
      "inputs": [],
      "name": "VELO",
      "outputs": [
        {
          "internalType": "contract IVelo",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "to",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        },
        {
          "internalType": "bytes32[]",
          "name": "proof",
          "type": "bytes32[]"
        }
      ],
      "name": "claim",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "name": "hasClaimed",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "merkleRoot",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0x244a338c51a7d9d1bb2405db83d844b85ebaf2d138c09a2e359669375face8ca",
  "receipt": {
    "to": null,
    "from": "0x53f3B51FD7F327E1Ec4E6eAa3A049149cB2acaD2",
    "contractAddress": "0xF32608868E215FC3164FDe378dca8D3741d0430A",
    "transactionIndex": 1,
    "gasUsed": "3703500",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0xcd293d89707cc0c8794c85e899fc285f0d25f827069ba5aa5f91051780ccac52",
    "transactionHash": "0x244a338c51a7d9d1bb2405db83d844b85ebaf2d138c09a2e359669375face8ca",
    "logs": [],
    "blockNumber": 53774144,
    "cumulativeGasUsed": "3703500",
    "status": 1,
    "byzantium": true
  },
  "args": [
    "0xC33f7f83CbB021846Cb9c58f2d8E3df428dbC8C1",
    "0xbb99a09fb3b8499385659e82a8da93596dd07082fe86981ec06c83181dee489f"
  ],
  "numDeployments": 1,
  "solcInputHash": "f93feb6db909c3f14d7eec3a3196fbbd",
  "metadata": "{\"compiler\":{\"version\":\"0.8.13+commit.abaa5c0e\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_velo\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"_merkleRoot\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Claim\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"VELO\",\"outputs\":[{\"internalType\":\"contract IVelo\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"proof\",\"type\":\"bytes32[]\"}],\"name\":\"claim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"hasClaimed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"merkleRoot\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"author\":\"Modified from Merkle Airdrop Starter (https://github.com/Anish-Agnihotri/merkle-airdrop-starter/blob/master/contracts/src/MerkleClaimERC20.sol)\",\"events\":{\"Claim(address,uint256)\":{\"params\":{\"amount\":\"of tokens claimed\",\"to\":\"recipient of claim\"}}},\"kind\":\"dev\",\"methods\":{\"claim(address,uint256,bytes32[])\":{\"params\":{\"amount\":\"of tokens owed to claimee\",\"proof\":\"merkle proof to prove address and amount are in tree\",\"to\":\"address of claimee\"}},\"constructor\":{\"params\":{\"_merkleRoot\":\"of claimees\",\"_velo\":\"address\"}}},\"title\":\"MerkleClaim\",\"version\":1},\"userdoc\":{\"events\":{\"Claim(address,uint256)\":{\"notice\":\"Emitted after a successful token claim\"}},\"kind\":\"user\",\"methods\":{\"VELO()\":{\"notice\":\"VELO token to claim\"},\"claim(address,uint256,bytes32[])\":{\"notice\":\"Allows claiming tokens if address is part of merkle tree\"},\"constructor\":{\"notice\":\"Creates a new MerkleClaim contract\"},\"hasClaimed(address)\":{\"notice\":\"Mapping of addresses who have claimed tokens\"},\"merkleRoot()\":{\"notice\":\"ERC20-claimee inclusion root\"}},\"notice\":\"Claims VELO for members of a merkle tree\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/redeem/MerkleClaim.sol\":\"MerkleClaim\"},\"evmVersion\":\"london\",\"libraries\":{\":__CACHE_BREAKER__\":\"0x0000000000000031363733393932363534393236\"},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"contracts/interfaces/IVelo.sol\":{\"content\":\"pragma solidity 0.8.13;\\n\\ninterface IVelo {\\n    function totalSupply() external view returns (uint);\\n    function balanceOf(address) external view returns (uint);\\n    function approve(address spender, uint value) external returns (bool);\\n    function transfer(address, uint) external returns (bool);\\n    function transferFrom(address,address,uint) external returns (bool);\\n    function mint(address, uint) external returns (bool);\\n    function minter() external returns (address);\\n    function claim(address, uint) external returns (bool);\\n}\\n\",\"keccak256\":\"0x4372772b06c7acb09381d2d722fbc927d580c8d8022512e2949bb7aded4f1699\"},\"contracts/redeem/MerkleClaim.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity 0.8.13;\\n\\n/// ============ Imports ============\\n\\nimport {IVelo} from \\\"contracts/interfaces/IVelo.sol\\\";\\nimport {MerkleProof} from \\\"lib/openzeppelin-contracts/contracts/utils/cryptography/MerkleProof.sol\\\"; // OZ: MerkleProof\\n\\n/// @title MerkleClaim\\n/// @notice Claims VELO for members of a merkle tree\\n/// @author Modified from Merkle Airdrop Starter (https://github.com/Anish-Agnihotri/merkle-airdrop-starter/blob/master/contracts/src/MerkleClaimERC20.sol)\\ncontract MerkleClaim {\\n    /// ============ Immutable storage ============\\n\\n    /// @notice VELO token to claim\\n    IVelo public immutable VELO;\\n    /// @notice ERC20-claimee inclusion root\\n    bytes32 public immutable merkleRoot;\\n\\n    /// ============ Mutable storage ============\\n\\n    /// @notice Mapping of addresses who have claimed tokens\\n    mapping(address => bool) public hasClaimed;\\n\\n    /// ============ Constructor ============\\n\\n    /// @notice Creates a new MerkleClaim contract\\n    /// @param _velo address\\n    /// @param _merkleRoot of claimees\\n    constructor(address _velo, bytes32 _merkleRoot) {\\n        VELO = IVelo(_velo);\\n        merkleRoot = _merkleRoot;\\n    }\\n\\n    /// ============ Events ============\\n\\n    /// @notice Emitted after a successful token claim\\n    /// @param to recipient of claim\\n    /// @param amount of tokens claimed\\n    event Claim(address indexed to, uint256 amount);\\n\\n    /// ============ Functions ============\\n\\n    /// @notice Allows claiming tokens if address is part of merkle tree\\n    /// @param to address of claimee\\n    /// @param amount of tokens owed to claimee\\n    /// @param proof merkle proof to prove address and amount are in tree\\n    function claim(\\n        address to,\\n        uint256 amount,\\n        bytes32[] calldata proof\\n    ) external {\\n        // Throw if address has already claimed tokens\\n        require(!hasClaimed[to], \\\"ALREADY_CLAIMED\\\");\\n\\n        // Verify merkle proof, or revert if not in tree\\n        bytes32 leaf = keccak256(abi.encodePacked(to, amount));\\n        bool isValidLeaf = MerkleProof.verify(proof, merkleRoot, leaf);\\n        require(isValidLeaf, \\\"NOT_IN_MERKLE\\\");\\n\\n        // Set address to claimed\\n        hasClaimed[to] = true;\\n\\n        // Claim tokens for address\\n        require(VELO.claim(to, amount), \\\"CLAIM_FAILED\\\");\\n\\n        // Emit claim event\\n        emit Claim(to, amount);\\n    }\\n}\\n\",\"keccak256\":\"0xb4724b0f4bf1f8a9f5ef9147e834b2d85ae61005ffc1d6b261f911c093f38270\",\"license\":\"AGPL-3.0-only\"},\"lib/openzeppelin-contracts/contracts/utils/cryptography/MerkleProof.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/cryptography/MerkleProof.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev These functions deal with verification of Merkle Tree proofs.\\n *\\n * The tree and the proofs can be generated using our\\n * https://github.com/OpenZeppelin/merkle-tree[JavaScript library].\\n * You will find a quickstart guide in the readme.\\n *\\n * WARNING: You should avoid using leaf values that are 64 bytes long prior to\\n * hashing, or use a hash function other than keccak256 for hashing leaves.\\n * This is because the concatenation of a sorted pair of internal nodes in\\n * the merkle tree could be reinterpreted as a leaf value.\\n * OpenZeppelin's JavaScript library generates merkle trees that are safe\\n * against this attack out of the box.\\n */\\nlibrary MerkleProof {\\n    /**\\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\\n     * defined by `root`. For this, a `proof` must be provided, containing\\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\\n     */\\n    function verify(bytes32[] memory proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\\n        return processProof(proof, leaf) == root;\\n    }\\n\\n    /**\\n     * @dev Calldata version of {verify}\\n     *\\n     * _Available since v4.7._\\n     */\\n    function verifyCalldata(bytes32[] calldata proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\\n        return processProofCalldata(proof, leaf) == root;\\n    }\\n\\n    /**\\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\\n     * hash matches the root of the tree. When processing the proof, the pairs\\n     * of leafs & pre-images are assumed to be sorted.\\n     *\\n     * _Available since v4.4._\\n     */\\n    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\\n        bytes32 computedHash = leaf;\\n        for (uint256 i = 0; i < proof.length; i++) {\\n            computedHash = _hashPair(computedHash, proof[i]);\\n        }\\n        return computedHash;\\n    }\\n\\n    /**\\n     * @dev Calldata version of {processProof}\\n     *\\n     * _Available since v4.7._\\n     */\\n    function processProofCalldata(bytes32[] calldata proof, bytes32 leaf) internal pure returns (bytes32) {\\n        bytes32 computedHash = leaf;\\n        for (uint256 i = 0; i < proof.length; i++) {\\n            computedHash = _hashPair(computedHash, proof[i]);\\n        }\\n        return computedHash;\\n    }\\n\\n    /**\\n     * @dev Returns true if the `leaves` can be simultaneously proven to be a part of a merkle tree defined by\\n     * `root`, according to `proof` and `proofFlags` as described in {processMultiProof}.\\n     *\\n     * CAUTION: Not all merkle trees admit multiproofs. See {processMultiProof} for details.\\n     *\\n     * _Available since v4.7._\\n     */\\n    function multiProofVerify(\\n        bytes32[] memory proof,\\n        bool[] memory proofFlags,\\n        bytes32 root,\\n        bytes32[] memory leaves\\n    ) internal pure returns (bool) {\\n        return processMultiProof(proof, proofFlags, leaves) == root;\\n    }\\n\\n    /**\\n     * @dev Calldata version of {multiProofVerify}\\n     *\\n     * CAUTION: Not all merkle trees admit multiproofs. See {processMultiProof} for details.\\n     *\\n     * _Available since v4.7._\\n     */\\n    function multiProofVerifyCalldata(\\n        bytes32[] calldata proof,\\n        bool[] calldata proofFlags,\\n        bytes32 root,\\n        bytes32[] memory leaves\\n    ) internal pure returns (bool) {\\n        return processMultiProofCalldata(proof, proofFlags, leaves) == root;\\n    }\\n\\n    /**\\n     * @dev Returns the root of a tree reconstructed from `leaves` and sibling nodes in `proof`. The reconstruction\\n     * proceeds by incrementally reconstructing all inner nodes by combining a leaf/inner node with either another\\n     * leaf/inner node or a proof sibling node, depending on whether each `proofFlags` item is true or false\\n     * respectively.\\n     *\\n     * CAUTION: Not all merkle trees admit multiproofs. To use multiproofs, it is sufficient to ensure that: 1) the tree\\n     * is complete (but not necessarily perfect), 2) the leaves to be proven are in the opposite order they are in the\\n     * tree (i.e., as seen from right to left starting at the deepest layer and continuing at the next layer).\\n     *\\n     * _Available since v4.7._\\n     */\\n    function processMultiProof(\\n        bytes32[] memory proof,\\n        bool[] memory proofFlags,\\n        bytes32[] memory leaves\\n    ) internal pure returns (bytes32 merkleRoot) {\\n        // This function rebuilds the root hash by traversing the tree up from the leaves. The root is rebuilt by\\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\\n        // the merkle tree.\\n        uint256 leavesLen = leaves.length;\\n        uint256 totalHashes = proofFlags.length;\\n\\n        // Check proof validity.\\n        require(leavesLen + proof.length - 1 == totalHashes, \\\"MerkleProof: invalid multiproof\\\");\\n\\n        // The xxxPos values are \\\"pointers\\\" to the next value to consume in each array. All accesses are done using\\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \\\"pop\\\".\\n        bytes32[] memory hashes = new bytes32[](totalHashes);\\n        uint256 leafPos = 0;\\n        uint256 hashPos = 0;\\n        uint256 proofPos = 0;\\n        // At each step, we compute the next hash using two values:\\n        // - a value from the \\\"main queue\\\". If not all leaves have been consumed, we get the next leaf, otherwise we\\n        //   get the next hash.\\n        // - depending on the flag, either another value from the \\\"main queue\\\" (merging branches) or an element from the\\n        //   `proof` array.\\n        for (uint256 i = 0; i < totalHashes; i++) {\\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\\n            bytes32 b = proofFlags[i]\\n                ? (leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++])\\n                : proof[proofPos++];\\n            hashes[i] = _hashPair(a, b);\\n        }\\n\\n        if (totalHashes > 0) {\\n            unchecked {\\n                return hashes[totalHashes - 1];\\n            }\\n        } else if (leavesLen > 0) {\\n            return leaves[0];\\n        } else {\\n            return proof[0];\\n        }\\n    }\\n\\n    /**\\n     * @dev Calldata version of {processMultiProof}.\\n     *\\n     * CAUTION: Not all merkle trees admit multiproofs. See {processMultiProof} for details.\\n     *\\n     * _Available since v4.7._\\n     */\\n    function processMultiProofCalldata(\\n        bytes32[] calldata proof,\\n        bool[] calldata proofFlags,\\n        bytes32[] memory leaves\\n    ) internal pure returns (bytes32 merkleRoot) {\\n        // This function rebuilds the root hash by traversing the tree up from the leaves. The root is rebuilt by\\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\\n        // the merkle tree.\\n        uint256 leavesLen = leaves.length;\\n        uint256 totalHashes = proofFlags.length;\\n\\n        // Check proof validity.\\n        require(leavesLen + proof.length - 1 == totalHashes, \\\"MerkleProof: invalid multiproof\\\");\\n\\n        // The xxxPos values are \\\"pointers\\\" to the next value to consume in each array. All accesses are done using\\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \\\"pop\\\".\\n        bytes32[] memory hashes = new bytes32[](totalHashes);\\n        uint256 leafPos = 0;\\n        uint256 hashPos = 0;\\n        uint256 proofPos = 0;\\n        // At each step, we compute the next hash using two values:\\n        // - a value from the \\\"main queue\\\". If not all leaves have been consumed, we get the next leaf, otherwise we\\n        //   get the next hash.\\n        // - depending on the flag, either another value from the \\\"main queue\\\" (merging branches) or an element from the\\n        //   `proof` array.\\n        for (uint256 i = 0; i < totalHashes; i++) {\\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\\n            bytes32 b = proofFlags[i]\\n                ? (leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++])\\n                : proof[proofPos++];\\n            hashes[i] = _hashPair(a, b);\\n        }\\n\\n        if (totalHashes > 0) {\\n            unchecked {\\n                return hashes[totalHashes - 1];\\n            }\\n        } else if (leavesLen > 0) {\\n            return leaves[0];\\n        } else {\\n            return proof[0];\\n        }\\n    }\\n\\n    function _hashPair(bytes32 a, bytes32 b) private pure returns (bytes32) {\\n        return a < b ? _efficientHash(a, b) : _efficientHash(b, a);\\n    }\\n\\n    function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, a)\\n            mstore(0x20, b)\\n            value := keccak256(0x00, 0x40)\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xcc76dbe53154a5bbd12fdd1613a73f73f3dc7c63d813be36f7ee606f52d6a7b3\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x60c060405234801561001057600080fd5b5060405161062638038061062683398101604081905261002f91610045565b6001600160a01b0390911660805260a05261007f565b6000806040838503121561005857600080fd5b82516001600160a01b038116811461006f57600080fd5b6020939093015192949293505050565b60805160a0516105766100b060003960008181605601526101ea01526000818160d8015261029601526105766000f3fe608060405234801561001057600080fd5b506004361061004c5760003560e01c80632eb4a7ab146100515780633d13f8741461008b57806373b2e80e146100a0578063a0eeb39a146100d3575b600080fd5b6100787f000000000000000000000000000000000000000000000000000000000000000081565b6040519081526020015b60405180910390f35b61009e61009936600461043c565b610112565b005b6100c36100ae3660046104c6565b60006020819052908152604090205460ff1681565b6040519015158152602001610082565b6100fa7f000000000000000000000000000000000000000000000000000000000000000081565b6040516001600160a01b039091168152602001610082565b6001600160a01b03841660009081526020819052604090205460ff16156101725760405162461bcd60e51b815260206004820152600f60248201526e1053149150511657d0d31052535151608a1b60448201526064015b60405180910390fd5b6040516bffffffffffffffffffffffff19606086901b1660208201526034810184905260009060540160405160208183030381529060405280519060200120905060006102158484808060200260200160405190810160405280939291908181526020018383602002808284376000920191909152507f0000000000000000000000000000000000000000000000000000000000000000925086915061038b9050565b9050806102545760405162461bcd60e51b815260206004820152600d60248201526c4e4f545f494e5f4d45524b4c4560981b6044820152606401610169565b6001600160a01b0386811660008181526020819052604090819020805460ff1916600117905551635569f64b60e11b81526004810191909152602481018790527f00000000000000000000000000000000000000000000000000000000000000009091169063aad3ec96906044016020604051808303816000875af11580156102e1573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061030591906104e1565b6103405760405162461bcd60e51b815260206004820152600c60248201526b10d310525357d1905253115160a21b6044820152606401610169565b856001600160a01b03167f47cee97cb7acd717b3c0aa1435d004cd5b3c8c57d70dbceb4e4458bbd60e39d48660405161037b91815260200190565b60405180910390a2505050505050565b60008261039885846103a1565b14949350505050565b600081815b84518110156103e6576103d2828683815181106103c5576103c5610503565b60200260200101516103ee565b9150806103de81610519565b9150506103a6565b509392505050565b600081831061040a576000828152602084905260409020610419565b60008381526020839052604090205b9392505050565b80356001600160a01b038116811461043757600080fd5b919050565b6000806000806060858703121561045257600080fd5b61045b85610420565b935060208501359250604085013567ffffffffffffffff8082111561047f57600080fd5b818701915087601f83011261049357600080fd5b8135818111156104a257600080fd5b8860208260051b85010111156104b757600080fd5b95989497505060200194505050565b6000602082840312156104d857600080fd5b61041982610420565b6000602082840312156104f357600080fd5b8151801515811461041957600080fd5b634e487b7160e01b600052603260045260246000fd5b60006001820161053957634e487b7160e01b600052601160045260246000fd5b506001019056fea26469706673582212207ff4a3058000aa2127bce11a4350a06b85715a38c4ec1fb8625704ba02ab001764736f6c634300080d0033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b506004361061004c5760003560e01c80632eb4a7ab146100515780633d13f8741461008b57806373b2e80e146100a0578063a0eeb39a146100d3575b600080fd5b6100787f000000000000000000000000000000000000000000000000000000000000000081565b6040519081526020015b60405180910390f35b61009e61009936600461043c565b610112565b005b6100c36100ae3660046104c6565b60006020819052908152604090205460ff1681565b6040519015158152602001610082565b6100fa7f000000000000000000000000000000000000000000000000000000000000000081565b6040516001600160a01b039091168152602001610082565b6001600160a01b03841660009081526020819052604090205460ff16156101725760405162461bcd60e51b815260206004820152600f60248201526e1053149150511657d0d31052535151608a1b60448201526064015b60405180910390fd5b6040516bffffffffffffffffffffffff19606086901b1660208201526034810184905260009060540160405160208183030381529060405280519060200120905060006102158484808060200260200160405190810160405280939291908181526020018383602002808284376000920191909152507f0000000000000000000000000000000000000000000000000000000000000000925086915061038b9050565b9050806102545760405162461bcd60e51b815260206004820152600d60248201526c4e4f545f494e5f4d45524b4c4560981b6044820152606401610169565b6001600160a01b0386811660008181526020819052604090819020805460ff1916600117905551635569f64b60e11b81526004810191909152602481018790527f00000000000000000000000000000000000000000000000000000000000000009091169063aad3ec96906044016020604051808303816000875af11580156102e1573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061030591906104e1565b6103405760405162461bcd60e51b815260206004820152600c60248201526b10d310525357d1905253115160a21b6044820152606401610169565b856001600160a01b03167f47cee97cb7acd717b3c0aa1435d004cd5b3c8c57d70dbceb4e4458bbd60e39d48660405161037b91815260200190565b60405180910390a2505050505050565b60008261039885846103a1565b14949350505050565b600081815b84518110156103e6576103d2828683815181106103c5576103c5610503565b60200260200101516103ee565b9150806103de81610519565b9150506103a6565b509392505050565b600081831061040a576000828152602084905260409020610419565b60008381526020839052604090205b9392505050565b80356001600160a01b038116811461043757600080fd5b919050565b6000806000806060858703121561045257600080fd5b61045b85610420565b935060208501359250604085013567ffffffffffffffff8082111561047f57600080fd5b818701915087601f83011261049357600080fd5b8135818111156104a257600080fd5b8860208260051b85010111156104b757600080fd5b95989497505060200194505050565b6000602082840312156104d857600080fd5b61041982610420565b6000602082840312156104f357600080fd5b8151801515811461041957600080fd5b634e487b7160e01b600052603260045260246000fd5b60006001820161053957634e487b7160e01b600052601160045260246000fd5b506001019056fea26469706673582212207ff4a3058000aa2127bce11a4350a06b85715a38c4ec1fb8625704ba02ab001764736f6c634300080d0033",
  "devdoc": {
    "author": "Modified from Merkle Airdrop Starter (https://github.com/Anish-Agnihotri/merkle-airdrop-starter/blob/master/contracts/src/MerkleClaimERC20.sol)",
    "events": {
      "Claim(address,uint256)": {
        "params": {
          "amount": "of tokens claimed",
          "to": "recipient of claim"
        }
      }
    },
    "kind": "dev",
    "methods": {
      "claim(address,uint256,bytes32[])": {
        "params": {
          "amount": "of tokens owed to claimee",
          "proof": "merkle proof to prove address and amount are in tree",
          "to": "address of claimee"
        }
      },
      "constructor": {
        "params": {
          "_merkleRoot": "of claimees",
          "_velo": "address"
        }
      }
    },
    "title": "MerkleClaim",
    "version": 1
  },
  "userdoc": {
    "events": {
      "Claim(address,uint256)": {
        "notice": "Emitted after a successful token claim"
      }
    },
    "kind": "user",
    "methods": {
      "VELO()": {
        "notice": "VELO token to claim"
      },
      "claim(address,uint256,bytes32[])": {
        "notice": "Allows claiming tokens if address is part of merkle tree"
      },
      "constructor": {
        "notice": "Creates a new MerkleClaim contract"
      },
      "hasClaimed(address)": {
        "notice": "Mapping of addresses who have claimed tokens"
      },
      "merkleRoot()": {
        "notice": "ERC20-claimee inclusion root"
      }
    },
    "notice": "Claims VELO for members of a merkle tree",
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 24472,
        "contract": "contracts/redeem/MerkleClaim.sol:MerkleClaim",
        "label": "hasClaimed",
        "offset": 0,
        "slot": "0",
        "type": "t_mapping(t_address,t_bool)"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_bool": {
        "encoding": "inplace",
        "label": "bool",
        "numberOfBytes": "1"
      },
      "t_mapping(t_address,t_bool)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => bool)",
        "numberOfBytes": "32",
        "value": "t_bool"
      }
    }
  }
}