{"compiler":{"version":"0.8.13+commit.abaa5c0e"},"language":"Solidity","output":{"abi":[{"inputs":[{"internalType":"address","name":"__voter","type":"address"},{"internalType":"address","name":"__ve","type":"address"},{"internalType":"address","name":"__rewards_distributor","type":"address"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"uint256","name":"weekly","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"circulating_supply","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"circulating_emission","type":"uint256"}],"name":"Mint","type":"event"},{"inputs":[],"name":"MAX_TEAM_RATE","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"_flow","outputs":[{"internalType":"contract IFlow","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"_rewards_distributor","outputs":[{"internalType":"contract IRewardsDistributor","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"_ve","outputs":[{"internalType":"contract IVotingEscrow","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"_voter","outputs":[{"internalType":"contract IVoter","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"acceptTeam","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"active_period","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"calculate_emission","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"_minted","type":"uint256"}],"name":"calculate_growth","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"circulating_emission","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"circulating_supply","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address[]","name":"claimants","type":"address[]"},{"internalType":"uint256[]","name":"amounts","type":"uint256[]"},{"internalType":"uint256","name":"max","type":"uint256"}],"name":"initialize","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"pendingTeam","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"_team","type":"address"}],"name":"setTeam","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"_teamRate","type":"uint256"}],"name":"setTeamRate","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"team","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"teamRate","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"update_period","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"weekly","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"weekly_emission","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"}],"devdoc":{"kind":"dev","methods":{},"version":1},"userdoc":{"kind":"user","methods":{},"version":1}},"settings":{"compilationTarget":{"contracts/Minter.sol":"Minter"},"evmVersion":"london","libraries":{":__CACHE_BREAKER__":"0x0000000000000031363736343730393337373039"},"metadata":{"bytecodeHash":"ipfs","useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[]},"sources":{"contracts/Minter.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport \"lib/openzeppelin-contracts/contracts/utils/math/Math.sol\";\n\nimport \"contracts/interfaces/IMinter.sol\";\nimport \"contracts/interfaces/IRewardsDistributor.sol\";\nimport \"contracts/interfaces/IFlow.sol\";\nimport \"contracts/interfaces/IVoter.sol\";\nimport \"contracts/interfaces/IVotingEscrow.sol\";\nimport \"contracts/interfaces/ITurnstile.sol\";\n\n// codifies the minting rules as per ve(3,3), abstracted from the token to support any token that allows minting\n\ncontract Minter is IMinter {\n    address internal multisig = 0x0a178469E3d08BEAA0a289E416Ab924F10807989;\n    address internal turnstile = 0xEcf044C5B4b867CFda001101c617eCd347095B44;\n    uint256 internal constant WEEK = 86400 * 7; // allows minting once per week (reset every Thursday 00:00 UTC)\n    uint256 internal constant EMISSION = 990;\n    uint256 internal constant TAIL_EMISSION = 2;\n    uint256 internal constant PRECISION = 1000;\n    IFlow public immutable _flow;\n    IVoter public immutable _voter;\n    IVotingEscrow public immutable _ve;\n    IRewardsDistributor public immutable _rewards_distributor;\n    uint256 public weekly = 15_000_000 * 1e18; // represents a starting weekly emission of 15M FLOW (FLOW has 18 decimals)\n    uint256 public active_period;\n    uint256 internal constant LOCK = 86400 * 7 * 52 * 4;\n\n    address internal initializer;\n    address public team;\n    address public pendingTeam;\n    uint256 public teamRate;\n    uint256 public constant MAX_TEAM_RATE = 50; // 5% max\n\n    event Mint(\n        address indexed sender,\n        uint256 weekly,\n        uint256 circulating_supply,\n        uint256 circulating_emission\n    );\n\n    constructor(\n        address __voter, // the voting & distribution system\n        address __ve, // the ve(3,3) system that will be locked into\n        address __rewards_distributor // the distribution system that ensures users aren't diluted\n    ) {\n        initializer = msg.sender;\n        team = msg.sender;\n        teamRate = 30; // 30 bps = 3%\n        _flow = IFlow(IVotingEscrow(__ve).token());\n        _voter = IVoter(__voter);\n        _ve = IVotingEscrow(__ve);\n        _rewards_distributor = IRewardsDistributor(__rewards_distributor);\n        active_period = ((block.timestamp + (2 * WEEK)) / WEEK) * WEEK;\n\n        ITurnstile(turnstile).register(multisig);\n    }\n\n    function initialize(\n        address[] memory claimants, // partnerAddrs\n        uint256[] memory amounts, // partnerAmounts\n        uint256 max // sum amounts / max = % ownership of top protocols, so if initial 20m is distributed, and target is 25% protocol ownership, then max - 4 x 20m = 80m\n    ) external {\n        require(initializer == msg.sender);\n        _flow.mint(address(this), max);\n        _flow.approve(address(_ve), type(uint256).max);\n        for (uint256 i = 0; i < claimants.length; i++) {\n            _ve.create_lock_for(amounts[i], LOCK, claimants[i]);\n        }\n        initializer = address(0);\n        active_period = ((block.timestamp) / WEEK) * WEEK; // allow minter.update_period() to mint new emissions THIS Thursday\n    }\n\n    function setTeam(address _team) external {\n        require(msg.sender == team, \"not team\");\n        pendingTeam = _team;\n    }\n\n    function acceptTeam() external {\n        require(msg.sender == pendingTeam, \"not pending team\");\n        team = pendingTeam;\n    }\n\n    function setTeamRate(uint256 _teamRate) external {\n        require(msg.sender == team, \"not team\");\n        require(_teamRate <= MAX_TEAM_RATE, \"rate too high\");\n        teamRate = _teamRate;\n    }\n\n    // calculate circulating supply as total token supply - locked supply\n    function circulating_supply() public view returns (uint256) {\n        return _flow.totalSupply() - _ve.totalSupply();\n    }\n\n    // emission calculation is 1% of available supply to mint adjusted by circulating / total supply\n    function calculate_emission() public view returns (uint256) {\n        return (weekly * EMISSION) / PRECISION;\n    }\n\n    // weekly emission takes the max of calculated (aka target) emission versus circulating tail end emission\n    function weekly_emission() public view returns (uint256) {\n        return Math.max(calculate_emission(), circulating_emission());\n    }\n\n    // calculates tail end (infinity) emissions as 0.2% of total supply\n    function circulating_emission() public view returns (uint256) {\n        return (circulating_supply() * TAIL_EMISSION) / PRECISION;\n    }\n\n    // calculate inflation and adjust ve balances accordingly\n    function calculate_growth(uint256 _minted) public view returns (uint256) {\n        uint256 _veTotal = _ve.totalSupply();\n        uint256 _flowTotal = _flow.totalSupply();\n        return\n            (((((_minted * _veTotal) / _flowTotal) * _veTotal) / _flowTotal) *\n                _veTotal) /\n            _flowTotal /\n            2;\n    }\n\n    // update period can only be called once per cycle (1 week)\n    function update_period() external returns (uint256) {\n        uint256 _period = active_period;\n        if (block.timestamp >= _period + WEEK && initializer == address(0)) {\n            // only trigger if new week\n            _period = (block.timestamp / WEEK) * WEEK;\n            active_period = _period;\n            weekly = weekly_emission();\n\n            uint256 _growth = calculate_growth(weekly);\n            uint256 _teamEmissions = (teamRate * (_growth + weekly)) /\n                (PRECISION - teamRate);\n            uint256 _required = _growth + weekly + _teamEmissions;\n            uint256 _balanceOf = _flow.balanceOf(address(this));\n            if (_balanceOf < _required) {\n                _flow.mint(address(this), _required - _balanceOf);\n            }\n\n            require(_flow.transfer(team, _teamEmissions));\n            require(_flow.transfer(address(_rewards_distributor), _growth));\n            _rewards_distributor.checkpoint_token(); // checkpoint token balance that was just minted in rewards distributor\n            _rewards_distributor.checkpoint_total_supply(); // checkpoint supply\n\n            _flow.approve(address(_voter), weekly);\n            _voter.notifyRewardAmount(weekly);\n\n            emit Mint(\n                msg.sender,\n                weekly,\n                circulating_supply(),\n                circulating_emission()\n            );\n        }\n        return _period;\n    }\n}\n","keccak256":"0x10f3e7b6b209fc7ef1d984e6ccaba1c3f2c63fd01126349a9ba95e4d9f54385d","license":"MIT"},"contracts/interfaces/IFlow.sol":{"content":"pragma solidity 0.8.13;\n\ninterface IFlow {\n    function totalSupply() external view returns (uint);\n    function balanceOf(address) external view returns (uint);\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address, uint) external returns (bool);\n    function transferFrom(address,address,uint) external returns (bool);\n    function mint(address, uint) external returns (bool);\n    function minter() external returns (address);\n    function claim(address, uint) external returns (bool);\n}\n","keccak256":"0x957c4997b5ac464df3484317f7526b8425008684147ab08af5e4bd10d5a60d8d"},"contracts/interfaces/IMinter.sol":{"content":"pragma solidity 0.8.13;\n\ninterface IMinter {\n    function update_period() external returns (uint);\n}\n","keccak256":"0x22a493b7559b31b779773d0279189161af0d6c0e741d470fd7a8afdf91558304"},"contracts/interfaces/IRewardsDistributor.sol":{"content":"pragma solidity 0.8.13;\n\ninterface IRewardsDistributor {\n    function checkpoint_token() external;\n    function checkpoint_total_supply() external;\n}\n","keccak256":"0x34c330b70b2b8847a6afce921a69eed82d1ecb3d2a0ee61401619a7b28e69243"},"contracts/interfaces/ITurnstile.sol":{"content":"interface ITurnstile {\n    function register(address) external returns(uint256);\n}","keccak256":"0xf19540479e9afad63b889bd1aaf665c5f989635ffc3259b9cfb600c079cf25f2"},"contracts/interfaces/IVoter.sol":{"content":"pragma solidity 0.8.13;\n\ninterface IVoter {\n    function _ve() external view returns (address);\n    function governor() external view returns (address);\n    function emergencyCouncil() external view returns (address);\n    function attachTokenToGauge(uint _tokenId, address account) external;\n    function detachTokenFromGauge(uint _tokenId, address account) external;\n    function emitDeposit(uint _tokenId, address account, uint amount) external;\n    function emitWithdraw(uint _tokenId, address account, uint amount) external;\n    function isWhitelisted(address token) external view returns (bool);\n    function notifyRewardAmount(uint amount) external;\n    function distribute(address _gauge) external;\n}\n","keccak256":"0x033115b88f156c6db67ca468fc9da8e4197bbd48bc8cf5a1652b9ebd307b2d31"},"contracts/interfaces/IVotingEscrow.sol":{"content":"pragma solidity 0.8.13;\n\ninterface IVotingEscrow {\n\n    struct Point {\n        int128 bias;\n        int128 slope; // # -dweight / dt\n        uint256 ts;\n        uint256 blk; // block\n    }\n\n    function token() external view returns (address);\n    function team() external returns (address);\n    function epoch() external view returns (uint);\n    function point_history(uint loc) external view returns (Point memory);\n    function user_point_history(uint tokenId, uint loc) external view returns (Point memory);\n    function user_point_epoch(uint tokenId) external view returns (uint);\n\n    function ownerOf(uint) external view returns (address);\n    function isApprovedOrOwner(address, uint) external view returns (bool);\n    function transferFrom(address, address, uint) external;\n\n    function voting(uint tokenId) external;\n    function abstain(uint tokenId) external;\n    function attach(uint tokenId) external;\n    function detach(uint tokenId) external;\n\n    function checkpoint() external;\n    function deposit_for(uint tokenId, uint value) external;\n    function create_lock_for(uint, uint, address) external returns (uint);\n\n    function balanceOfNFT(uint) external view returns (uint);\n    function totalSupply() external view returns (uint);\n}\n","keccak256":"0x9c51afef11e82c70d08871264602e385a4f7caf36383e1bc5a6c214f93a4c0d1"},"lib/openzeppelin-contracts/contracts/utils/math/Math.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1, \"Math: mulDiv overflow\");\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // \u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // \u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}\n","keccak256":"0x3546b156d97633f7f8cad536d5454c81d1d604687c02b2eb105fdc33cb962b41","license":"MIT"}},"version":1}