{"compiler":{"version":"0.8.13+commit.abaa5c0e"},"language":"Solidity","output":{"abi":[{"inputs":[],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"token0","type":"address"},{"indexed":true,"internalType":"address","name":"token1","type":"address"},{"indexed":false,"internalType":"bool","name":"stable","type":"bool"},{"indexed":false,"internalType":"address","name":"pair","type":"address"},{"indexed":false,"internalType":"uint256","name":"","type":"uint256"}],"name":"PairCreated","type":"event"},{"inputs":[],"name":"MAX_FEE","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"acceptFeeManager","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"acceptPauser","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"_tank","type":"address"}],"name":"acceptTank","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"","type":"uint256"}],"name":"allPairs","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"allPairsLength","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"tokenA","type":"address"},{"internalType":"address","name":"tokenB","type":"address"},{"internalType":"bool","name":"stable","type":"bool"}],"name":"createPair","outputs":[{"internalType":"address","name":"pair","type":"address"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"deployer","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"feeManager","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bool","name":"_stable","type":"bool"}],"name":"getFee","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"getInitializable","outputs":[{"internalType":"address","name":"","type":"address"},{"internalType":"address","name":"","type":"address"},{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"","type":"address"},{"internalType":"address","name":"","type":"address"},{"internalType":"bool","name":"","type":"bool"}],"name":"getPair","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"getVoter","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"","type":"address"}],"name":"isPair","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"isPaused","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"pairCodeHash","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"pure","type":"function"},{"inputs":[],"name":"pauser","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"pendingFeeManager","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"pendingPauser","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bool","name":"_stable","type":"bool"},{"internalType":"uint256","name":"_fee","type":"uint256"}],"name":"setFee","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"_feeManager","type":"address"}],"name":"setFeeManager","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bool","name":"_state","type":"bool"}],"name":"setPause","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"_pauser","type":"address"}],"name":"setPauser","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"_tank","type":"address"}],"name":"setTank","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"_team","type":"address"}],"name":"setTeam","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"_voter","type":"address"}],"name":"setVoter","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"stableFee","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"tank","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"team","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"volatileFee","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"voter","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"}],"devdoc":{"kind":"dev","methods":{},"version":1},"userdoc":{"kind":"user","methods":{},"version":1}},"settings":{"compilationTarget":{"contracts/factories/PairFactory.sol":"PairFactory"},"evmVersion":"london","libraries":{":__CACHE_BREAKER__":"0x0000000000000031363736343730343737303032"},"metadata":{"bytecodeHash":"ipfs","useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[]},"sources":{"contracts/Pair.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport \"lib/openzeppelin-contracts/contracts/utils/math/Math.sol\";\nimport \"contracts/interfaces/IERC20.sol\";\nimport \"contracts/interfaces/IPair.sol\";\nimport \"contracts/interfaces/IPairCallee.sol\";\nimport \"contracts/factories/PairFactory.sol\";\nimport \"contracts/PairFees.sol\";\n\nimport \"contracts/interfaces/IBribe.sol\";\nimport \"contracts/interfaces/ITurnstile.sol\";\n\n// The base pair of pools, either stable or volatile\ncontract Pair is IPair {\n    address internal multisig = 0x0a178469E3d08BEAA0a289E416Ab924F10807989;\n    address internal turnstile = 0xEcf044C5B4b867CFda001101c617eCd347095B44;\n    string public name;\n    string public symbol;\n    uint8 public constant decimals = 18;\n\n    // Used to denote stable or volatile pair, not immutable since construction happens in the initialize method for CREATE2 deterministic addresses\n    bool public immutable stable;\n\n    uint256 public totalSupply = 0;\n\n    mapping(address => mapping(address => uint256)) public allowance;\n    mapping(address => uint256) public balanceOf;\n\n    bytes32 internal DOMAIN_SEPARATOR;\n    // keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n    bytes32 internal constant PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\n    mapping(address => uint256) public nonces;\n\n    uint256 internal constant MINIMUM_LIQUIDITY = 10 ** 3;\n\n    address public immutable token0;\n    address public immutable token1;\n    address public immutable fees;\n    address immutable factory; // explain this? can this be public? can I call this from inside a contract\n    address public externalBribe;\n    address public immutable voter;\n    address public immutable tank;\n    bool public hasGauge;\n\n    // Structure to capture time period obervations every 30 minutes, used for local oracles\n    struct Observation {\n        uint256 timestamp;\n        uint256 reserve0Cumulative;\n        uint256 reserve1Cumulative;\n    }\n\n    // Capture oracle reading every 30 minutes\n    uint256 constant periodSize = 1800;\n\n    Observation[] public observations;\n\n    uint256 internal immutable decimals0;\n    uint256 internal immutable decimals1;\n\n    uint256 public reserve0;\n    uint256 public reserve1;\n    uint256 public blockTimestampLast;\n\n    uint256 public reserve0CumulativeLast;\n    uint256 public reserve1CumulativeLast;\n\n    // index0 and index1 are used to accumulate fees, this is split out from normal trades to keep the swap \"clean\"\n    // this further allows LP holders to easily claim fees for tokens they have/staked\n    uint256 public index0 = 0;\n    uint256 public index1 = 0;\n\n    // position assigned to each LP to track their current index0 & index1 vs the global position\n    mapping(address => uint256) public supplyIndex0;\n    mapping(address => uint256) public supplyIndex1;\n\n    // tracks the amount of unclaimed, but claimable tokens off of fees for token0 and token1\n    mapping(address => uint256) public claimable0;\n    mapping(address => uint256) public claimable1;\n\n    event Fees(address indexed sender, uint256 amount0, uint256 amount1);\n    event TankFees(address indexed token, uint256 amount0, address tank);\n    event GaugeFees(address indexed token, uint256 amount0, address externalBribe);\n    event Mint(address indexed sender, uint256 amount0, uint256 amount1);\n    event Burn(address indexed sender, uint256 amount0, uint256 amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint256 amount0In,\n        uint256 amount1In,\n        uint256 amount0Out,\n        uint256 amount1Out,\n        address indexed to\n    );\n    event Sync(uint256 reserve0, uint256 reserve1);\n    event Claim(address indexed sender, address indexed recipient, uint256 amount0, uint256 amount1);\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n\n    constructor() {\n        factory = msg.sender;\n        voter = PairFactory(msg.sender).voter(); // nice easy way to add the voter :) we already getting this from pair factory tho\n        tank = PairFactory(msg.sender).tank(); // nice easy way to add the voter :) we already getting this from pair factory tho\n        (address _token0, address _token1, bool _stable) = PairFactory(msg.sender).getInitializable(); //wondering why msg.sender is passed here??\n        (token0, token1, stable) = (_token0, _token1, _stable);\n        fees = address(new PairFees(_token0, _token1));\n        //     externalBribe = address();  this does not need to be set at the time of creation\n        if (_stable) {\n            name = string(abi.encodePacked(\"StableV1 AMM - \", IERC20(_token0).symbol(), \"/\", IERC20(_token1).symbol()));\n            symbol = string(abi.encodePacked(\"sAMM-\", IERC20(_token0).symbol(), \"/\", IERC20(_token1).symbol()));\n        } else {\n            name =\n                string(abi.encodePacked(\"VolatileV1 AMM - \", IERC20(_token0).symbol(), \"/\", IERC20(_token1).symbol()));\n            symbol = string(abi.encodePacked(\"vAMM-\", IERC20(_token0).symbol(), \"/\", IERC20(_token1).symbol()));\n        }\n\n        decimals0 = 10 ** IERC20(_token0).decimals();\n        decimals1 = 10 ** IERC20(_token1).decimals();\n\n        observations.push(Observation(block.timestamp, 0, 0));\n\n        ITurnstile(turnstile).register(multisig);\n    }\n\n    // simple re-entrancy check\n    uint256 internal _unlocked = 1;\n\n    modifier lock() {\n        require(_unlocked == 1);\n        _unlocked = 2;\n        _;\n        _unlocked = 1;\n    }\n\n    function _safeApprove(address token, address spender, uint256 value) internal {\n        require(token.code.length > 0);\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(IERC20.approve.selector, spender, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))));\n    }\n\n    function setExternalBribe(address _externalBribe) external {\n        require(msg.sender == voter, \"Only voter can set external bribe\");\n        externalBribe = _externalBribe;\n        _safeApprove(token0, externalBribe, type(uint256).max);\n        _safeApprove(token1, externalBribe, type(uint256).max);\n        // _safeApprove(token0, externalBribe, amount);\n    }\n\n    function setHasGauge(bool value) external {\n        require(msg.sender == voter, \"Only voter can set has gauge\");\n        hasGauge = value;\n    }\n\n    function observationLength() external view returns (uint256) {\n        return observations.length;\n    }\n\n    function lastObservation() public view returns (Observation memory) {\n        return observations[observations.length - 1];\n    }\n\n    function metadata()\n        external\n        view\n        returns (uint256 dec0, uint256 dec1, uint256 r0, uint256 r1, bool st, address t0, address t1)\n    {\n        return (decimals0, decimals1, reserve0, reserve1, stable, token0, token1);\n    }\n\n    function tokens() external view returns (address, address) {\n        return (token0, token1);\n    }\n\n    // claim accumulated but unclaimed fees (viewable via claimable0 and claimable1)\n    function claimFees() external returns (uint256 claimed0, uint256 claimed1) {\n        _updateFor(msg.sender);\n\n        claimed0 = claimable0[msg.sender];\n        claimed1 = claimable1[msg.sender];\n\n        if (claimed0 > 0 || claimed1 > 0) {\n            claimable0[msg.sender] = 0;\n            claimable1[msg.sender] = 0;\n\n            PairFees(fees).claimFeesFor(msg.sender, claimed0, claimed1);\n\n            emit Claim(msg.sender, msg.sender, claimed0, claimed1);\n        }\n    }\n\n    // dunks update0\n\n    // Accrue fees on token0\n    // function _update0(uint256 amount) internal {\n    //     _safeTransfer(token0, fees, amount); // transfer the fees out to PairFees\n    //     uint256 _ratio = (amount * 1e18) / totalSupply; // 1e18 adjustment is removed during claim\n    //     if (_ratio > 0) {\n    //         index0 += _ratio;\n    //     }\n    //     emit Fees(msg.sender, amount, 0);\n    // }\n\n    // // Accrue fees on token1\n    // function _update1(uint256 amount) internal {\n    //     _safeTransfer(token1, fees, amount);\n    //     uint256 _ratio = (amount * 1e18) / totalSupply;\n    //     if (_ratio > 0) {\n    //         index1 += _ratio;\n    //     }\n    //     emit Fees(msg.sender, 0, amount);\n    // }\n\n    // Accrue fees on token0.\n    function _update0(uint256 amount) internal {\n        if (hasGauge == false) {\n            _safeTransfer(token0, tank, amount); // transfer the fees to tank MSig for gaugeless LPs\n            uint256 _ratio = (amount * 1e18) / totalSupply; // 1e18 adjustment is removed during claim\n            if (_ratio > 0) {\n                index0 += _ratio;\n            }\n            emit TankFees(token0, amount, tank);\n        }\n        if (hasGauge == true) {\n            // _safeApprove(token0, externalBribe, amount);  // max abprove when setExternalBribe() is called\n            IBribe(externalBribe).notifyRewardAmount(token0, amount); //transfer fees to exBribes\n            //  _safeTransfer(token0, tank, amount);\n            uint256 _ratio = (amount * 1e18) / totalSupply; // 1e18 adjustment is removed during claim\n            if (_ratio > 0) {\n                index0 += _ratio;\n            }\n            emit GaugeFees(token0, amount, externalBribe);\n        }\n    }\n\n    // Accrue fees on token1\n    function _update1(uint256 amount) internal {\n        if (hasGauge == false) {\n            _safeTransfer(token1, tank, amount); // transfer the fees to tank MSig for gaugeless LPs\n            uint256 _ratio = (amount * 1e18) / totalSupply; // 1e18 adjustment is removed during claim\n            if (_ratio > 0) {\n                index0 += _ratio;\n            }\n            emit TankFees(token1, amount, tank);\n        }\n        if (hasGauge == true) {\n            //there is no interface for external bribe so this errors\n            // _safeApprove(token1, externalBribe, amount); // we do this once above\n            IBribe(externalBribe).notifyRewardAmount(token1, amount); //transfer fees to exBribes\n            uint256 _ratio = (amount * 1e18) / totalSupply; // 1e18 adjustment is removed during claim\n            if (_ratio > 0) {\n                index0 += _ratio;\n            }\n            emit GaugeFees(token1, amount, externalBribe);\n        }\n    }\n\n    // this function MUST be called on any balance changes, otherwise can be used to infinitely claim fees\n    // Fees are segregated from core funds, so fees can never put liquidity at risk\n    function _updateFor(address recipient) internal {\n        uint256 _supplied = balanceOf[recipient]; // get LP balance of `recipient`\n        if (_supplied > 0) {\n            uint256 _supplyIndex0 = supplyIndex0[recipient]; // get last adjusted index0 for recipient\n            uint256 _supplyIndex1 = supplyIndex1[recipient];\n            uint256 _index0 = index0; // get global index0 for accumulated fees\n            uint256 _index1 = index1;\n            supplyIndex0[recipient] = _index0; // update user current position to global position\n            supplyIndex1[recipient] = _index1;\n            uint256 _delta0 = _index0 - _supplyIndex0; // see if there is any difference that need to be accrued\n            uint256 _delta1 = _index1 - _supplyIndex1;\n            if (_delta0 > 0) {\n                uint256 _share = (_supplied * _delta0) / 1e18; // add accrued difference for each supplied token\n                claimable0[recipient] += _share;\n            }\n            if (_delta1 > 0) {\n                uint256 _share = (_supplied * _delta1) / 1e18;\n                claimable1[recipient] += _share;\n            }\n        } else {\n            supplyIndex0[recipient] = index0; // new users are set to the default global state\n            supplyIndex1[recipient] = index1;\n        }\n    }\n\n    function getReserves() public view returns (uint256 _reserve0, uint256 _reserve1, uint256 _blockTimestampLast) {\n        _reserve0 = reserve0;\n        _reserve1 = reserve1;\n        _blockTimestampLast = blockTimestampLast;\n    }\n\n    // update reserves and, on the first call per block, price accumulators\n    function _update(uint256 balance0, uint256 balance1, uint256 _reserve0, uint256 _reserve1) internal {\n        uint256 blockTimestamp = block.timestamp;\n        uint256 timeElapsed = blockTimestamp - blockTimestampLast; // overflow is desired\n        if (timeElapsed > 0 && _reserve0 != 0 && _reserve1 != 0) {\n            reserve0CumulativeLast += _reserve0 * timeElapsed;\n            reserve1CumulativeLast += _reserve1 * timeElapsed;\n        }\n\n        Observation memory _point = lastObservation();\n        timeElapsed = blockTimestamp - _point.timestamp; // compare the last observation with current timestamp, if greater than 30 minutes, record a new event\n        if (timeElapsed > periodSize) {\n            observations.push(Observation(blockTimestamp, reserve0CumulativeLast, reserve1CumulativeLast));\n        }\n        reserve0 = balance0;\n        reserve1 = balance1;\n        blockTimestampLast = blockTimestamp;\n        emit Sync(reserve0, reserve1);\n    }\n\n    // produces the cumulative price using counterfactuals to save gas and avoid a call to sync.\n    function currentCumulativePrices()\n        public\n        view\n        returns (uint256 reserve0Cumulative, uint256 reserve1Cumulative, uint256 blockTimestamp)\n    {\n        blockTimestamp = block.timestamp;\n        reserve0Cumulative = reserve0CumulativeLast;\n        reserve1Cumulative = reserve1CumulativeLast;\n\n        // if time has elapsed since the last update on the pair, mock the accumulated price values\n        (uint256 _reserve0, uint256 _reserve1, uint256 _blockTimestampLast) = getReserves();\n        if (_blockTimestampLast != blockTimestamp) {\n            // subtraction overflow is desired\n            uint256 timeElapsed = blockTimestamp - _blockTimestampLast;\n            reserve0Cumulative += _reserve0 * timeElapsed;\n            reserve1Cumulative += _reserve1 * timeElapsed;\n        }\n    }\n\n    // gives the current twap price measured from amountIn * tokenIn gives amountOut\n    function current(address tokenIn, uint256 amountIn) external view returns (uint256 amountOut) {\n        Observation memory _observation = lastObservation();\n        (uint256 reserve0Cumulative, uint256 reserve1Cumulative,) = currentCumulativePrices();\n        if (block.timestamp == _observation.timestamp) {\n            _observation = observations[observations.length - 2];\n        }\n\n        uint256 timeElapsed = block.timestamp - _observation.timestamp;\n        uint256 _reserve0 = (reserve0Cumulative - _observation.reserve0Cumulative) / timeElapsed;\n        uint256 _reserve1 = (reserve1Cumulative - _observation.reserve1Cumulative) / timeElapsed;\n        amountOut = _getAmountOut(amountIn, tokenIn, _reserve0, _reserve1);\n    }\n\n    // as per `current`, however allows user configured granularity, up to the full window size\n    function quote(address tokenIn, uint256 amountIn, uint256 granularity) external view returns (uint256 amountOut) {\n        uint256[] memory _prices = sample(tokenIn, amountIn, granularity, 1);\n        uint256 priceAverageCumulative;\n        for (uint256 i = 0; i < _prices.length; i++) {\n            priceAverageCumulative += _prices[i];\n        }\n        return priceAverageCumulative / granularity;\n    }\n\n    // returns a memory set of twap prices\n    function prices(address tokenIn, uint256 amountIn, uint256 points) external view returns (uint256[] memory) {\n        return sample(tokenIn, amountIn, points, 1);\n    }\n\n    function sample(address tokenIn, uint256 amountIn, uint256 points, uint256 window)\n        public\n        view\n        returns (uint256[] memory)\n    {\n        uint256[] memory _prices = new uint256[](points);\n\n        uint256 length = observations.length - 1;\n        uint256 i = length - (points * window);\n        uint256 nextIndex = 0;\n        uint256 index = 0;\n\n        for (; i < length; i += window) {\n            nextIndex = i + window;\n            uint256 timeElapsed = observations[nextIndex].timestamp - observations[i].timestamp;\n            uint256 _reserve0 =\n                (observations[nextIndex].reserve0Cumulative - observations[i].reserve0Cumulative) / timeElapsed;\n            uint256 _reserve1 =\n                (observations[nextIndex].reserve1Cumulative - observations[i].reserve1Cumulative) / timeElapsed;\n            _prices[index] = _getAmountOut(amountIn, tokenIn, _reserve0, _reserve1);\n            // index < length; length cannot overflow\n            unchecked {\n                index = index + 1;\n            }\n        }\n        return _prices;\n    }\n\n    // this low-level function should be called by addLiquidity functions in Router.sol, which performs important safety checks\n    // standard uniswap v2 implementation\n    function mint(address to) external lock returns (uint256 liquidity) {\n        (uint256 _reserve0, uint256 _reserve1) = (reserve0, reserve1);\n        uint256 _balance0 = IERC20(token0).balanceOf(address(this));\n        uint256 _balance1 = IERC20(token1).balanceOf(address(this));\n        uint256 _amount0 = _balance0 - _reserve0;\n        uint256 _amount1 = _balance1 - _reserve1;\n\n        uint256 _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee\n        if (_totalSupply == 0) {\n            liquidity = Math.sqrt(_amount0 * _amount1) - MINIMUM_LIQUIDITY;\n            _mint(address(0), MINIMUM_LIQUIDITY); // permanently lock the first MINIMUM_LIQUIDITY tokens\n        } else {\n            liquidity = Math.min((_amount0 * _totalSupply) / _reserve0, (_amount1 * _totalSupply) / _reserve1);\n        }\n        require(liquidity > 0, \"ILM\"); // Pair: INSUFFICIENT_LIQUIDITY_MINTED\n        _mint(to, liquidity);\n\n        _update(_balance0, _balance1, _reserve0, _reserve1);\n        emit Mint(msg.sender, _amount0, _amount1);\n    }\n\n    // this low-level function should be called from a contract which performs important safety checks\n    // standard uniswap v2 implementation\n    function burn(address to) external lock returns (uint256 amount0, uint256 amount1) {\n        (uint256 _reserve0, uint256 _reserve1) = (reserve0, reserve1);\n        (address _token0, address _token1) = (token0, token1);\n        uint256 _balance0 = IERC20(_token0).balanceOf(address(this));\n        uint256 _balance1 = IERC20(_token1).balanceOf(address(this));\n        uint256 _liquidity = balanceOf[address(this)];\n\n        uint256 _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee\n        amount0 = (_liquidity * _balance0) / _totalSupply; // using balances ensures pro-rata distribution\n        amount1 = (_liquidity * _balance1) / _totalSupply; // using balances ensures pro-rata distribution\n        require(amount0 > 0 && amount1 > 0, \"ILB\"); // Pair: INSUFFICIENT_LIQUIDITY_BURNED\n        _burn(address(this), _liquidity);\n        _safeTransfer(_token0, to, amount0);\n        _safeTransfer(_token1, to, amount1);\n        _balance0 = IERC20(_token0).balanceOf(address(this));\n        _balance1 = IERC20(_token1).balanceOf(address(this));\n\n        _update(_balance0, _balance1, _reserve0, _reserve1);\n        emit Burn(msg.sender, amount0, amount1, to);\n    }\n\n    // this low-level function should be called from a contract which performs important safety checks\n    function swap(uint256 amount0Out, uint256 amount1Out, address to, bytes calldata data) external lock {\n        require(!PairFactory(factory).isPaused());\n        require(amount0Out > 0 || amount1Out > 0, \"IOA\"); // Pair: INSUFFICIENT_OUTPUT_AMOUNT\n        (uint256 _reserve0, uint256 _reserve1) = (reserve0, reserve1);\n        require(amount0Out < _reserve0 && amount1Out < _reserve1, \"IL\"); // Pair: INSUFFICIENT_LIQUIDITY\n\n        uint256 _balance0;\n        uint256 _balance1;\n        {\n            // scope for _token{0,1}, avoids stack too deep errors\n            (address _token0, address _token1) = (token0, token1);\n            require(to != _token0 && to != _token1, \"IT\"); // Pair: INVALID_TO\n            if (amount0Out > 0) _safeTransfer(_token0, to, amount0Out); // optimistically transfer tokens\n            if (amount1Out > 0) _safeTransfer(_token1, to, amount1Out); // optimistically transfer tokens\n            if (data.length > 0) {\n                IPairCallee(to).hook(msg.sender, amount0Out, amount1Out, data);\n            } // callback, used for flash loans\n            _balance0 = IERC20(_token0).balanceOf(address(this));\n            _balance1 = IERC20(_token1).balanceOf(address(this));\n        }\n        uint256 amount0In = _balance0 > _reserve0 - amount0Out ? _balance0 - (_reserve0 - amount0Out) : 0;\n        uint256 amount1In = _balance1 > _reserve1 - amount1Out ? _balance1 - (_reserve1 - amount1Out) : 0;\n        require(amount0In > 0 || amount1In > 0, \"IIA\"); // Pair: INSUFFICIENT_INPUT_AMOUNT\n        {\n            // scope for reserve{0,1}Adjusted, avoids stack too deep errors\n            (address _token0, address _token1) = (token0, token1);\n            if (amount0In > 0) {\n                _update0((amount0In * PairFactory(factory).getFee(stable)) / 10000);\n            } // accrue fees for token0 and move them out of pool\n            if (amount1In > 0) {\n                _update1((amount1In * PairFactory(factory).getFee(stable)) / 10000);\n            } // accrue fees for token1 and move them out of pool\n            _balance0 = IERC20(_token0).balanceOf(address(this)); // since we removed tokens, we need to reconfirm balances, can also simply use previous balance - amountIn/ 10000, but doing balanceOf again as safety check\n            _balance1 = IERC20(_token1).balanceOf(address(this));\n            // The curve, either x3y+y3x for stable pools, or x*y for volatile pools\n            require(_k(_balance0, _balance1) >= _k(_reserve0, _reserve1), \"K\"); // Pair: K\n        }\n\n        _update(_balance0, _balance1, _reserve0, _reserve1);\n        emit Swap(msg.sender, amount0In, amount1In, amount0Out, amount1Out, to);\n    }\n\n    // force balances to match reserves\n    function skim(address to) external lock {\n        (address _token0, address _token1) = (token0, token1);\n        _safeTransfer(_token0, to, IERC20(_token0).balanceOf(address(this)) - (reserve0));\n        _safeTransfer(_token1, to, IERC20(_token1).balanceOf(address(this)) - (reserve1));\n    }\n\n    // force reserves to match balances\n    function sync() external lock {\n        _update(IERC20(token0).balanceOf(address(this)), IERC20(token1).balanceOf(address(this)), reserve0, reserve1);\n    }\n\n    function _f(uint256 x0, uint256 y) internal pure returns (uint256) {\n        return (x0 * ((((y * y) / 1e18) * y) / 1e18)) / 1e18 + (((((x0 * x0) / 1e18) * x0) / 1e18) * y) / 1e18;\n    }\n\n    function _d(uint256 x0, uint256 y) internal pure returns (uint256) {\n        return (3 * x0 * ((y * y) / 1e18)) / 1e18 + ((((x0 * x0) / 1e18) * x0) / 1e18);\n    }\n\n    function _get_y(uint256 x0, uint256 xy, uint256 y) internal pure returns (uint256) {\n        for (uint256 i = 0; i < 255; i++) {\n            uint256 y_prev = y;\n            uint256 k = _f(x0, y);\n            if (k < xy) {\n                uint256 dy = ((xy - k) * 1e18) / _d(x0, y);\n                y = y + dy;\n            } else {\n                uint256 dy = ((k - xy) * 1e18) / _d(x0, y);\n                y = y - dy;\n            }\n            if (y > y_prev) {\n                if (y - y_prev <= 1) {\n                    return y;\n                }\n            } else {\n                if (y_prev - y <= 1) {\n                    return y;\n                }\n            }\n        }\n        return y;\n    }\n\n    function getAmountOut(uint256 amountIn, address tokenIn) external view returns (uint256) {\n        (uint256 _reserve0, uint256 _reserve1) = (reserve0, reserve1);\n        amountIn -= (amountIn * PairFactory(factory).getFee(stable)) / 10000; // remove fee from amount received\n        return _getAmountOut(amountIn, tokenIn, _reserve0, _reserve1);\n    }\n\n    function _getAmountOut(uint256 amountIn, address tokenIn, uint256 _reserve0, uint256 _reserve1)\n        internal\n        view\n        returns (uint256)\n    {\n        if (stable) {\n            uint256 xy = _k(_reserve0, _reserve1);\n            _reserve0 = (_reserve0 * 1e18) / decimals0;\n            _reserve1 = (_reserve1 * 1e18) / decimals1;\n            (uint256 reserveA, uint256 reserveB) = tokenIn == token0 ? (_reserve0, _reserve1) : (_reserve1, _reserve0);\n            amountIn = tokenIn == token0 ? (amountIn * 1e18) / decimals0 : (amountIn * 1e18) / decimals1;\n            uint256 y = reserveB - _get_y(amountIn + reserveA, xy, reserveB);\n            return (y * (tokenIn == token0 ? decimals1 : decimals0)) / 1e18;\n        } else {\n            (uint256 reserveA, uint256 reserveB) = tokenIn == token0 ? (_reserve0, _reserve1) : (_reserve1, _reserve0);\n            return (amountIn * reserveB) / (reserveA + amountIn);\n        }\n    }\n\n    function _k(uint256 x, uint256 y) internal view returns (uint256) {\n        if (stable) {\n            uint256 _x = (x * 1e18) / decimals0;\n            uint256 _y = (y * 1e18) / decimals1;\n            uint256 _a = (_x * _y) / 1e18;\n            uint256 _b = ((_x * _x) / 1e18 + (_y * _y) / 1e18);\n            return (_a * _b) / 1e18; // x3y+y3x >= k\n        } else {\n            return x * y; // xy >= k\n        }\n    }\n\n    function _mint(address dst, uint256 amount) internal {\n        _updateFor(dst); // balances must be updated on mint/burn/transfer\n        totalSupply += amount;\n        balanceOf[dst] += amount;\n        emit Transfer(address(0), dst, amount);\n    }\n\n    function _burn(address dst, uint256 amount) internal {\n        _updateFor(dst);\n        totalSupply -= amount;\n        balanceOf[dst] -= amount;\n        emit Transfer(dst, address(0), amount);\n    }\n\n    function approve(address spender, uint256 amount) external returns (bool) {\n        allowance[msg.sender][spender] = amount;\n\n        emit Approval(msg.sender, spender, amount);\n        return true;\n    }\n\n    function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s)\n        external\n    {\n        require(deadline >= block.timestamp, \"Pair: EXPIRED\");\n        DOMAIN_SEPARATOR = keccak256(\n            abi.encode(\n                keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\n                keccak256(bytes(name)),\n                keccak256(bytes(\"1\")),\n                block.chainid,\n                address(this)\n            )\n        );\n        bytes32 digest = keccak256(\n            abi.encodePacked(\n                \"\\x19\\x01\",\n                DOMAIN_SEPARATOR,\n                keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline))\n            )\n        );\n        address recoveredAddress = ecrecover(digest, v, r, s);\n        require(recoveredAddress != address(0) && recoveredAddress == owner, \"Pair: INVALID_SIGNATURE\");\n        allowance[owner][spender] = value;\n\n        emit Approval(owner, spender, value);\n    }\n\n    function transfer(address dst, uint256 amount) external returns (bool) {\n        _transferTokens(msg.sender, dst, amount);\n        return true;\n    }\n\n    function transferFrom(address src, address dst, uint256 amount) external returns (bool) {\n        address spender = msg.sender;\n        uint256 spenderAllowance = allowance[src][spender];\n\n        if (spender != src && spenderAllowance != type(uint256).max) {\n            uint256 newAllowance = spenderAllowance - amount;\n            allowance[src][spender] = newAllowance;\n\n            emit Approval(src, spender, newAllowance);\n        }\n\n        _transferTokens(src, dst, amount);\n        return true;\n    }\n\n    function _transferTokens(address src, address dst, uint256 amount) internal {\n        _updateFor(src); // update fee position for src\n        _updateFor(dst); // update fee position for dst\n\n        balanceOf[src] -= amount;\n        balanceOf[dst] += amount;\n\n        emit Transfer(src, dst, amount);\n    }\n\n    function _safeTransfer(address token, address to, uint256 value) internal {\n        require(token.code.length > 0);\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(IERC20.transfer.selector, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))));\n    }\n}\n","keccak256":"0x28ea7dd8afb495d76e14281c02c9c2e4b0e95b3ec0bf5b30a9b9f22ee99ab0ba","license":"MIT"},"contracts/PairFees.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport 'contracts/interfaces/IERC20.sol';\nimport \"contracts/interfaces/ITurnstile.sol\";\n\n// Pair Fees contract is used as a 1:1 pair relationship to split out fees, this ensures that the curve does not need to be modified for LP shares\ncontract PairFees {\n    address internal multisig = 0x0a178469E3d08BEAA0a289E416Ab924F10807989;\n    address internal turnstile = 0xEcf044C5B4b867CFda001101c617eCd347095B44;\n\n    address internal immutable pair; // The pair it is bonded to\n    address internal immutable token0; // token0 of pair, saved localy and statically for gas optimization\n    address internal immutable token1; // Token1 of pair, saved localy and statically for gas optimization\n\n    constructor(address _token0, address _token1) {\n        pair = msg.sender;\n        token0 = _token0;\n        token1 = _token1;\n\n        ITurnstile(turnstile).register(multisig);\n    }\n\n    function _safeTransfer(address token,address to,uint256 value) internal {\n        require(token.code.length > 0);\n        (bool success, bytes memory data) =\n        token.call(abi.encodeWithSelector(IERC20.transfer.selector, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))));\n    }\n\n    // Allow the pair to transfer fees to users\n    function claimFeesFor(address recipient, uint amount0, uint amount1) external {\n        require(msg.sender == pair);\n        if (amount0 > 0) _safeTransfer(token0, recipient, amount0);\n        if (amount1 > 0) _safeTransfer(token1, recipient, amount1);\n    }\n\n}\n","keccak256":"0xaf9b1ccb2d51a752f668572cfc2b3c076173a1e2f584dfcad5c00314d4c10753","license":"MIT"},"contracts/factories/PairFactory.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport \"contracts/interfaces/IPairFactory.sol\";\nimport \"contracts/Pair.sol\";\nimport \"contracts/interfaces/ITurnstile.sol\";\n\ncontract PairFactory is IPairFactory {\n    address internal multisig = 0x0a178469E3d08BEAA0a289E416Ab924F10807989;\n    address internal turnstile = 0xEcf044C5B4b867CFda001101c617eCd347095B44;\n    bool public isPaused;\n    address public pauser;\n    address public pendingPauser;\n\n    uint256 public stableFee;\n    uint256 public volatileFee;\n    uint256 public constant MAX_FEE = 50; // 0.5%\n    address public feeManager;\n    address public pendingFeeManager;\n    address public voter;\n    address public team;\n    bool internal initial_voter_set;\n    bool internal initial_tank_set;\n    address public tank;\n    address public deployer;\n\n    mapping(address => mapping(address => mapping(bool => address)))\n        public getPair;\n    address[] public allPairs;\n    mapping(address => bool) public isPair; // simplified check if its a pair, given that `stable` flag might not be available in peripherals\n\n    address internal _temp0;\n    address internal _temp1;\n    bool internal _temp;\n\n    event PairCreated(\n        address indexed token0,\n        address indexed token1,\n        bool stable,\n        address pair,\n        uint256\n    );\n\n    constructor() {\n        pauser = msg.sender;\n        isPaused = false;\n        feeManager = msg.sender;\n        // stableFee = 2; // 0.02%\n        // volatileFee = 2;\n        stableFee = 3; // 0.03%\n        volatileFee = 25; // 0.25%\n        deployer = msg.sender;\n\n        ITurnstile(turnstile).register(multisig);\n    }\n\n    // need to set team so that team can set voter we really only need to set the voter once :) - deployer can do this only once (either in the init script but then we have to do this one last otherwise it will fail)\n\n    function setTeam(address _team) external {\n        require(msg.sender == deployer); // might need to set this to deployer?? or just make it\n        require(team == address(0), \"The team has already been set.\");\n        team = _team;\n    }\n\n    // In this example, the owner variable is set to the address that deploys the contract in the constructor. The setTeam function requires that the caller (msg.sender) must be the owner, and that the team variable has not yet been set (it is equal to the address value of 0). If either of these conditions are not met, the function will revert and not update the team variable.\n\n    // we only get once shot at this.\n\n    function setVoter(address _voter) external {\n        require(!initial_voter_set, \"The voter has already been set.\");\n        require(msg.sender == deployer); // have to make sure that this can be set to the voter addres during init script\n        voter = _voter;\n        initial_voter_set = true;\n    }\n\n    // function set tank on factory require team\n\n    function setTank(address _tank) external {\n        require(!initial_tank_set, \"The tank has already been set.\");\n        require(msg.sender == deployer); // this should be updateable to team but adding deployer so that init script can run..\n        tank = _tank;\n        initial_tank_set = true;\n    }\n\n    // This makes tank updateable forever by the team address (multisig)\n\n    function acceptTank(address _tank) external {\n        require(msg.sender == team, \"not pending team\");\n        tank = _tank;\n    }\n\n    // pair uses this to check if voter is updating external_bribe\n\n    function getVoter() external view returns (address) {\n        return voter;\n    }\n\n    function allPairsLength() external view returns (uint256) {\n        return allPairs.length;\n    }\n\n    function setPauser(address _pauser) external {\n        require(msg.sender == pauser);\n        pendingPauser = _pauser;\n    }\n\n    function acceptPauser() external {\n        require(msg.sender == pendingPauser);\n        pauser = pendingPauser;\n    }\n\n    function setPause(bool _state) external {\n        require(msg.sender == pauser);\n        isPaused = _state;\n    }\n\n    function setFeeManager(address _feeManager) external {\n        require(msg.sender == feeManager, \"not fee manager\");\n        pendingFeeManager = _feeManager;\n    }\n\n    function acceptFeeManager() external {\n        require(msg.sender == pendingFeeManager, \"not pending fee manager\");\n        feeManager = pendingFeeManager;\n    }\n\n    function setFee(bool _stable, uint256 _fee) external {\n        require(msg.sender == feeManager, \"not fee manager\");\n        require(_fee <= MAX_FEE, \"fee too high\");\n        require(_fee != 0, \"fee must be nonzero\");\n        if (_stable) {\n            stableFee = _fee;\n        } else {\n            volatileFee = _fee;\n        }\n    }\n\n    function getFee(bool _stable) public view returns (uint256) {\n        return _stable ? stableFee : volatileFee;\n    }\n\n    function pairCodeHash() external pure returns (bytes32) {\n        return keccak256(type(Pair).creationCode);\n    }\n\n    function getInitializable()\n        external\n        view\n        returns (\n            address,\n            address,\n            bool\n        )\n    {\n        return (_temp0, _temp1, _temp);\n    }\n\n    function createPair(\n        address tokenA,\n        address tokenB,\n        bool stable\n    ) external returns (address pair) {\n        require(tokenA != tokenB, \"IA\"); // Pair: IDENTICAL_ADDRESSES\n        (address token0, address token1) = tokenA < tokenB\n            ? (tokenA, tokenB)\n            : (tokenB, tokenA);\n        require(token0 != address(0), \"ZA\"); // Pair: ZERO_ADDRESS\n        require(getPair[token0][token1][stable] == address(0), \"PE\"); // Pair: PAIR_EXISTS - single check is sufficient\n        bytes32 salt = keccak256(abi.encodePacked(token0, token1, stable)); // notice salt includes stable as well, 3 parameters\n        (_temp0, _temp1, _temp) = (token0, token1, stable);\n        pair = address(new Pair{salt: salt}());\n        getPair[token0][token1][stable] = pair;\n        getPair[token1][token0][stable] = pair; // populate mapping in the reverse direction\n        allPairs.push(pair);\n        isPair[pair] = true;\n        emit PairCreated(token0, token1, stable, pair, allPairs.length);\n    }\n}\n","keccak256":"0x52db19f074fba9d8be01977cf21ee0ef1dbc9f828da22f08f81fbd41d7eb3bfd","license":"MIT"},"contracts/interfaces/IBribe.sol":{"content":"pragma solidity 0.8.13;\n\ninterface IBribe {\n    function _deposit(uint256 amount, uint256 tokenId) external;\n    function _withdraw(uint256 amount, uint256 tokenId) external;\n    function getRewardForOwner(uint256 tokenId, address[] memory tokens) external;\n    function notifyRewardAmount(address token, uint256 amount) external; //keep same as external bribe\n    function left(address token) external view returns (uint256);\n}\n","keccak256":"0x05d9a4d56b9e7ef3e876873b0ef701474a7b5cca9494d61f083bd3207d531f74"},"contracts/interfaces/IERC20.sol":{"content":"pragma solidity 0.8.13;\n\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n    function transfer(address recipient, uint amount) external returns (bool);\n    function decimals() external view returns (uint8);\n    function symbol() external view returns (string memory);\n    function balanceOf(address) external view returns (uint);\n    function transferFrom(address sender, address recipient, uint amount) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint);\n    function approve(address spender, uint value) external returns (bool);\n\n    event Transfer(address indexed from, address indexed to, uint value);\n    event Approval(address indexed owner, address indexed spender, uint value);\n}\n","keccak256":"0x892b167ec5245b43ccdfc68d20e8ca12d05725fb6c11ec5ddf6bf77ed0c93c32"},"contracts/interfaces/IPair.sol":{"content":"pragma solidity 0.8.13;\n\ninterface IPair {\n    function metadata() external view returns (uint dec0, uint dec1, uint r0, uint r1, bool st, address t0, address t1);\n    function claimFees() external returns (uint, uint);\n    function tokens() external returns (address, address);\n    function transferFrom(address src, address dst, uint amount) external returns (bool);\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function mint(address to) external returns (uint liquidity);\n    function getReserves() external view returns (uint _reserve0, uint _reserve1, uint _blockTimestampLast);\n    function getAmountOut(uint, address) external view returns (uint);\n}\n","keccak256":"0x796005a0babe921334bacab4a90a551bc7f2ddfb030350a6ba590a9d8440daee"},"contracts/interfaces/IPairCallee.sol":{"content":"pragma solidity 0.8.13;\n\ninterface IPairCallee {\n    function hook(address sender, uint amount0, uint amount1, bytes calldata data) external;\n}\n","keccak256":"0x3ac2de2c7a08bf59fd1006e4d108b247916369de15fbd048b72ca2b7814023ca"},"contracts/interfaces/IPairFactory.sol":{"content":"pragma solidity 0.8.13;\n\ninterface IPairFactory {\n    function allPairsLength() external view returns (uint);\n    function isPair(address pair) external view returns (bool);\n    function pairCodeHash() external pure returns (bytes32);\n    function getPair(address tokenA, address token, bool stable) external view returns (address);\n    function createPair(address tokenA, address tokenB, bool stable) external returns (address pair);\n}\n","keccak256":"0x6a1b9f617020d6a2e0f8cadd51288f5000b0e0dae938a84dc5c977c88c849738"},"contracts/interfaces/ITurnstile.sol":{"content":"interface ITurnstile {\n    function register(address) external returns(uint256);\n}","keccak256":"0xf19540479e9afad63b889bd1aaf665c5f989635ffc3259b9cfb600c079cf25f2"},"lib/openzeppelin-contracts/contracts/utils/math/Math.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1, \"Math: mulDiv overflow\");\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // \u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // \u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}\n","keccak256":"0x3546b156d97633f7f8cad536d5454c81d1d604687c02b2eb105fdc33cb962b41","license":"MIT"}},"version":1}