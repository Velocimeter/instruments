{"compiler":{"version":"0.8.13+commit.abaa5c0e"},"language":"Solidity","output":{"abi":[{"inputs":[],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"token0","type":"address"},{"indexed":true,"internalType":"address","name":"token1","type":"address"},{"indexed":false,"internalType":"bool","name":"stable","type":"bool"},{"indexed":false,"internalType":"address","name":"pair","type":"address"},{"indexed":false,"internalType":"uint256","name":"","type":"uint256"}],"name":"PairCreated","type":"event"},{"inputs":[],"name":"MAX_FEE","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"acceptFeeManager","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"acceptPauser","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"","type":"uint256"}],"name":"allPairs","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"allPairsLength","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"tokenA","type":"address"},{"internalType":"address","name":"tokenB","type":"address"},{"internalType":"bool","name":"stable","type":"bool"}],"name":"createPair","outputs":[{"internalType":"address","name":"pair","type":"address"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"feeManager","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bool","name":"_stable","type":"bool"}],"name":"getFee","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"getInitializable","outputs":[{"internalType":"address","name":"","type":"address"},{"internalType":"address","name":"","type":"address"},{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"","type":"address"},{"internalType":"address","name":"","type":"address"},{"internalType":"bool","name":"","type":"bool"}],"name":"getPair","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"","type":"address"}],"name":"isPair","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"isPaused","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"pairCodeHash","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"pure","type":"function"},{"inputs":[],"name":"pauser","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"pendingFeeManager","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"pendingPauser","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bool","name":"_stable","type":"bool"},{"internalType":"uint256","name":"_fee","type":"uint256"}],"name":"setFee","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"_feeManager","type":"address"}],"name":"setFeeManager","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bool","name":"_state","type":"bool"}],"name":"setPause","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"_pauser","type":"address"}],"name":"setPauser","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"stableFee","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"volatileFee","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"}],"devdoc":{"kind":"dev","methods":{},"version":1},"userdoc":{"kind":"user","methods":{},"version":1}},"settings":{"compilationTarget":{"contracts/factories/PairFactory.sol":"PairFactory"},"evmVersion":"london","libraries":{":__CACHE_BREAKER__":"0x0000000000000031363735333231323839353834"},"metadata":{"bytecodeHash":"ipfs","useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[]},"sources":{"contracts/Pair.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport \"contracts/libraries/Math.sol\";\nimport \"contracts/interfaces/IERC20.sol\";\nimport \"contracts/interfaces/IPair.sol\";\nimport \"contracts/interfaces/IPairCallee.sol\";\nimport \"contracts/factories/PairFactory.sol\";\nimport \"contracts/PairFees.sol\";\n\n// The base pair of pools, either stable or volatile\ncontract Pair is IPair {\n    string public name;\n    string public symbol;\n    uint8 public constant decimals = 18;\n\n    // Used to denote stable or volatile pair, not immutable since construction happens in the initialize method for CREATE2 deterministic addresses\n    bool public immutable stable;\n\n    uint256 public totalSupply = 0;\n\n    mapping(address => mapping(address => uint256)) public allowance;\n    mapping(address => uint256) public balanceOf;\n\n    bytes32 internal DOMAIN_SEPARATOR;\n    // keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n    bytes32 internal constant PERMIT_TYPEHASH =\n        0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\n    mapping(address => uint256) public nonces;\n\n    uint256 internal constant MINIMUM_LIQUIDITY = 10**3;\n\n    address public immutable token0;\n    address public immutable token1;\n    address public immutable fees;\n    address immutable factory;\n\n    // Structure to capture time period obervations every 30 minutes, used for local oracles\n    struct Observation {\n        uint256 timestamp;\n        uint256 reserve0Cumulative;\n        uint256 reserve1Cumulative;\n    }\n\n    // Capture oracle reading every 30 minutes\n    uint256 constant periodSize = 1800;\n\n    Observation[] public observations;\n\n    uint256 internal immutable decimals0;\n    uint256 internal immutable decimals1;\n\n    uint256 public reserve0;\n    uint256 public reserve1;\n    uint256 public blockTimestampLast;\n\n    uint256 public reserve0CumulativeLast;\n    uint256 public reserve1CumulativeLast;\n\n    // index0 and index1 are used to accumulate fees, this is split out from normal trades to keep the swap \"clean\"\n    // this further allows LP holders to easily claim fees for tokens they have/staked\n    uint256 public index0 = 0;\n    uint256 public index1 = 0;\n\n    // position assigned to each LP to track their current index0 & index1 vs the global position\n    mapping(address => uint256) public supplyIndex0;\n    mapping(address => uint256) public supplyIndex1;\n\n    // tracks the amount of unclaimed, but claimable tokens off of fees for token0 and token1\n    mapping(address => uint256) public claimable0;\n    mapping(address => uint256) public claimable1;\n\n    event Fees(address indexed sender, uint256 amount0, uint256 amount1);\n    event Mint(address indexed sender, uint256 amount0, uint256 amount1);\n    event Burn(\n        address indexed sender,\n        uint256 amount0,\n        uint256 amount1,\n        address indexed to\n    );\n    event Swap(\n        address indexed sender,\n        uint256 amount0In,\n        uint256 amount1In,\n        uint256 amount0Out,\n        uint256 amount1Out,\n        address indexed to\n    );\n    event Sync(uint256 reserve0, uint256 reserve1);\n    event Claim(\n        address indexed sender,\n        address indexed recipient,\n        uint256 amount0,\n        uint256 amount1\n    );\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 amount\n    );\n\n    constructor() {\n        factory = msg.sender;\n        (address _token0, address _token1, bool _stable) = PairFactory(\n            msg.sender\n        ).getInitializable();\n        (token0, token1, stable) = (_token0, _token1, _stable);\n        fees = address(new PairFees(_token0, _token1));\n        if (_stable) {\n            name = string(\n                abi.encodePacked(\n                    \"StableV1 AMM - \",\n                    IERC20(_token0).symbol(),\n                    \"/\",\n                    IERC20(_token1).symbol()\n                )\n            );\n            symbol = string(\n                abi.encodePacked(\n                    \"sAMM-\",\n                    IERC20(_token0).symbol(),\n                    \"/\",\n                    IERC20(_token1).symbol()\n                )\n            );\n        } else {\n            name = string(\n                abi.encodePacked(\n                    \"VolatileV1 AMM - \",\n                    IERC20(_token0).symbol(),\n                    \"/\",\n                    IERC20(_token1).symbol()\n                )\n            );\n            symbol = string(\n                abi.encodePacked(\n                    \"vAMM-\",\n                    IERC20(_token0).symbol(),\n                    \"/\",\n                    IERC20(_token1).symbol()\n                )\n            );\n        }\n\n        decimals0 = 10**IERC20(_token0).decimals();\n        decimals1 = 10**IERC20(_token1).decimals();\n\n        observations.push(Observation(block.timestamp, 0, 0));\n    }\n\n    // simple re-entrancy check\n    uint256 internal _unlocked = 1;\n    modifier lock() {\n        require(_unlocked == 1);\n        _unlocked = 2;\n        _;\n        _unlocked = 1;\n    }\n\n    function observationLength() external view returns (uint256) {\n        return observations.length;\n    }\n\n    function lastObservation() public view returns (Observation memory) {\n        return observations[observations.length - 1];\n    }\n\n    function metadata()\n        external\n        view\n        returns (\n            uint256 dec0,\n            uint256 dec1,\n            uint256 r0,\n            uint256 r1,\n            bool st,\n            address t0,\n            address t1\n        )\n    {\n        return (\n            decimals0,\n            decimals1,\n            reserve0,\n            reserve1,\n            stable,\n            token0,\n            token1\n        );\n    }\n\n    function tokens() external view returns (address, address) {\n        return (token0, token1);\n    }\n\n    // claim accumulated but unclaimed fees (viewable via claimable0 and claimable1)\n    function claimFees() external returns (uint256 claimed0, uint256 claimed1) {\n        _updateFor(msg.sender);\n\n        claimed0 = claimable0[msg.sender];\n        claimed1 = claimable1[msg.sender];\n\n        if (claimed0 > 0 || claimed1 > 0) {\n            claimable0[msg.sender] = 0;\n            claimable1[msg.sender] = 0;\n\n            PairFees(fees).claimFeesFor(msg.sender, claimed0, claimed1);\n\n            emit Claim(msg.sender, msg.sender, claimed0, claimed1);\n        }\n    }\n\n    // Accrue fees on token0\n    function _update0(uint256 amount) internal {\n        _safeTransfer(token0, fees, amount); // transfer the fees out to PairFees\n        uint256 _ratio = (amount * 1e18) / totalSupply; // 1e18 adjustment is removed during claim\n        if (_ratio > 0) {\n            index0 += _ratio;\n        }\n        emit Fees(msg.sender, amount, 0);\n    }\n\n    // Accrue fees on token1\n    function _update1(uint256 amount) internal {\n        _safeTransfer(token1, fees, amount);\n        uint256 _ratio = (amount * 1e18) / totalSupply;\n        if (_ratio > 0) {\n            index1 += _ratio;\n        }\n        emit Fees(msg.sender, 0, amount);\n    }\n\n    // this function MUST be called on any balance changes, otherwise can be used to infinitely claim fees\n    // Fees are segregated from core funds, so fees can never put liquidity at risk\n    function _updateFor(address recipient) internal {\n        uint256 _supplied = balanceOf[recipient]; // get LP balance of `recipient`\n        if (_supplied > 0) {\n            uint256 _supplyIndex0 = supplyIndex0[recipient]; // get last adjusted index0 for recipient\n            uint256 _supplyIndex1 = supplyIndex1[recipient];\n            uint256 _index0 = index0; // get global index0 for accumulated fees\n            uint256 _index1 = index1;\n            supplyIndex0[recipient] = _index0; // update user current position to global position\n            supplyIndex1[recipient] = _index1;\n            uint256 _delta0 = _index0 - _supplyIndex0; // see if there is any difference that need to be accrued\n            uint256 _delta1 = _index1 - _supplyIndex1;\n            if (_delta0 > 0) {\n                uint256 _share = (_supplied * _delta0) / 1e18; // add accrued difference for each supplied token\n                claimable0[recipient] += _share;\n            }\n            if (_delta1 > 0) {\n                uint256 _share = (_supplied * _delta1) / 1e18;\n                claimable1[recipient] += _share;\n            }\n        } else {\n            supplyIndex0[recipient] = index0; // new users are set to the default global state\n            supplyIndex1[recipient] = index1;\n        }\n    }\n\n    function getReserves()\n        public\n        view\n        returns (\n            uint256 _reserve0,\n            uint256 _reserve1,\n            uint256 _blockTimestampLast\n        )\n    {\n        _reserve0 = reserve0;\n        _reserve1 = reserve1;\n        _blockTimestampLast = blockTimestampLast;\n    }\n\n    // update reserves and, on the first call per block, price accumulators\n    function _update(\n        uint256 balance0,\n        uint256 balance1,\n        uint256 _reserve0,\n        uint256 _reserve1\n    ) internal {\n        uint256 blockTimestamp = block.timestamp;\n        uint256 timeElapsed = blockTimestamp - blockTimestampLast; // overflow is desired\n        if (timeElapsed > 0 && _reserve0 != 0 && _reserve1 != 0) {\n            reserve0CumulativeLast += _reserve0 * timeElapsed;\n            reserve1CumulativeLast += _reserve1 * timeElapsed;\n        }\n\n        Observation memory _point = lastObservation();\n        timeElapsed = blockTimestamp - _point.timestamp; // compare the last observation with current timestamp, if greater than 30 minutes, record a new event\n        if (timeElapsed > periodSize) {\n            observations.push(\n                Observation(\n                    blockTimestamp,\n                    reserve0CumulativeLast,\n                    reserve1CumulativeLast\n                )\n            );\n        }\n        reserve0 = balance0;\n        reserve1 = balance1;\n        blockTimestampLast = blockTimestamp;\n        emit Sync(reserve0, reserve1);\n    }\n\n    // produces the cumulative price using counterfactuals to save gas and avoid a call to sync.\n    function currentCumulativePrices()\n        public\n        view\n        returns (\n            uint256 reserve0Cumulative,\n            uint256 reserve1Cumulative,\n            uint256 blockTimestamp\n        )\n    {\n        blockTimestamp = block.timestamp;\n        reserve0Cumulative = reserve0CumulativeLast;\n        reserve1Cumulative = reserve1CumulativeLast;\n\n        // if time has elapsed since the last update on the pair, mock the accumulated price values\n        (\n            uint256 _reserve0,\n            uint256 _reserve1,\n            uint256 _blockTimestampLast\n        ) = getReserves();\n        if (_blockTimestampLast != blockTimestamp) {\n            // subtraction overflow is desired\n            uint256 timeElapsed = blockTimestamp - _blockTimestampLast;\n            reserve0Cumulative += _reserve0 * timeElapsed;\n            reserve1Cumulative += _reserve1 * timeElapsed;\n        }\n    }\n\n    // gives the current twap price measured from amountIn * tokenIn gives amountOut\n    function current(address tokenIn, uint256 amountIn)\n        external\n        view\n        returns (uint256 amountOut)\n    {\n        Observation memory _observation = lastObservation();\n        (\n            uint256 reserve0Cumulative,\n            uint256 reserve1Cumulative,\n\n        ) = currentCumulativePrices();\n        if (block.timestamp == _observation.timestamp) {\n            _observation = observations[observations.length - 2];\n        }\n\n        uint256 timeElapsed = block.timestamp - _observation.timestamp;\n        uint256 _reserve0 = (reserve0Cumulative -\n            _observation.reserve0Cumulative) / timeElapsed;\n        uint256 _reserve1 = (reserve1Cumulative -\n            _observation.reserve1Cumulative) / timeElapsed;\n        amountOut = _getAmountOut(amountIn, tokenIn, _reserve0, _reserve1);\n    }\n\n    // as per `current`, however allows user configured granularity, up to the full window size\n    function quote(\n        address tokenIn,\n        uint256 amountIn,\n        uint256 granularity\n    ) external view returns (uint256 amountOut) {\n        uint256[] memory _prices = sample(tokenIn, amountIn, granularity, 1);\n        uint256 priceAverageCumulative;\n        for (uint256 i = 0; i < _prices.length; i++) {\n            priceAverageCumulative += _prices[i];\n        }\n        return priceAverageCumulative / granularity;\n    }\n\n    // returns a memory set of twap prices\n    function prices(\n        address tokenIn,\n        uint256 amountIn,\n        uint256 points\n    ) external view returns (uint256[] memory) {\n        return sample(tokenIn, amountIn, points, 1);\n    }\n\n    function sample(\n        address tokenIn,\n        uint256 amountIn,\n        uint256 points,\n        uint256 window\n    ) public view returns (uint256[] memory) {\n        uint256[] memory _prices = new uint256[](points);\n\n        uint256 length = observations.length - 1;\n        uint256 i = length - (points * window);\n        uint256 nextIndex = 0;\n        uint256 index = 0;\n\n        for (; i < length; i += window) {\n            nextIndex = i + window;\n            uint256 timeElapsed = observations[nextIndex].timestamp -\n                observations[i].timestamp;\n            uint256 _reserve0 = (observations[nextIndex].reserve0Cumulative -\n                observations[i].reserve0Cumulative) / timeElapsed;\n            uint256 _reserve1 = (observations[nextIndex].reserve1Cumulative -\n                observations[i].reserve1Cumulative) / timeElapsed;\n            _prices[index] = _getAmountOut(\n                amountIn,\n                tokenIn,\n                _reserve0,\n                _reserve1\n            );\n            // index < length; length cannot overflow\n            unchecked {\n                index = index + 1;\n            }\n        }\n        return _prices;\n    }\n\n    // this low-level function should be called by addLiquidity functions in Router.sol, which performs important safety checks\n    // standard uniswap v2 implementation\n    function mint(address to) external lock returns (uint256 liquidity) {\n        (uint256 _reserve0, uint256 _reserve1) = (reserve0, reserve1);\n        uint256 _balance0 = IERC20(token0).balanceOf(address(this));\n        uint256 _balance1 = IERC20(token1).balanceOf(address(this));\n        uint256 _amount0 = _balance0 - _reserve0;\n        uint256 _amount1 = _balance1 - _reserve1;\n\n        uint256 _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee\n        if (_totalSupply == 0) {\n            liquidity = MathDunks.sqrt(_amount0 * _amount1) - MINIMUM_LIQUIDITY;\n            _mint(address(0), MINIMUM_LIQUIDITY); // permanently lock the first MINIMUM_LIQUIDITY tokens\n        } else {\n            liquidity = MathDunks.min(\n                (_amount0 * _totalSupply) / _reserve0,\n                (_amount1 * _totalSupply) / _reserve1\n            );\n        }\n        require(liquidity > 0, \"ILM\"); // Pair: INSUFFICIENT_LIQUIDITY_MINTED\n        _mint(to, liquidity);\n\n        _update(_balance0, _balance1, _reserve0, _reserve1);\n        emit Mint(msg.sender, _amount0, _amount1);\n    }\n\n    // this low-level function should be called from a contract which performs important safety checks\n    // standard uniswap v2 implementation\n    function burn(address to)\n        external\n        lock\n        returns (uint256 amount0, uint256 amount1)\n    {\n        (uint256 _reserve0, uint256 _reserve1) = (reserve0, reserve1);\n        (address _token0, address _token1) = (token0, token1);\n        uint256 _balance0 = IERC20(_token0).balanceOf(address(this));\n        uint256 _balance1 = IERC20(_token1).balanceOf(address(this));\n        uint256 _liquidity = balanceOf[address(this)];\n\n        uint256 _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee\n        amount0 = (_liquidity * _balance0) / _totalSupply; // using balances ensures pro-rata distribution\n        amount1 = (_liquidity * _balance1) / _totalSupply; // using balances ensures pro-rata distribution\n        require(amount0 > 0 && amount1 > 0, \"ILB\"); // Pair: INSUFFICIENT_LIQUIDITY_BURNED\n        _burn(address(this), _liquidity);\n        _safeTransfer(_token0, to, amount0);\n        _safeTransfer(_token1, to, amount1);\n        _balance0 = IERC20(_token0).balanceOf(address(this));\n        _balance1 = IERC20(_token1).balanceOf(address(this));\n\n        _update(_balance0, _balance1, _reserve0, _reserve1);\n        emit Burn(msg.sender, amount0, amount1, to);\n    }\n\n    // this low-level function should be called from a contract which performs important safety checks\n    function swap(\n        uint256 amount0Out,\n        uint256 amount1Out,\n        address to,\n        bytes calldata data\n    ) external lock {\n        require(!PairFactory(factory).isPaused());\n        require(amount0Out > 0 || amount1Out > 0, \"IOA\"); // Pair: INSUFFICIENT_OUTPUT_AMOUNT\n        (uint256 _reserve0, uint256 _reserve1) = (reserve0, reserve1);\n        require(amount0Out < _reserve0 && amount1Out < _reserve1, \"IL\"); // Pair: INSUFFICIENT_LIQUIDITY\n\n        uint256 _balance0;\n        uint256 _balance1;\n        {\n            // scope for _token{0,1}, avoids stack too deep errors\n            (address _token0, address _token1) = (token0, token1);\n            require(to != _token0 && to != _token1, \"IT\"); // Pair: INVALID_TO\n            if (amount0Out > 0) _safeTransfer(_token0, to, amount0Out); // optimistically transfer tokens\n            if (amount1Out > 0) _safeTransfer(_token1, to, amount1Out); // optimistically transfer tokens\n            if (data.length > 0)\n                IPairCallee(to).hook(msg.sender, amount0Out, amount1Out, data); // callback, used for flash loans\n            _balance0 = IERC20(_token0).balanceOf(address(this));\n            _balance1 = IERC20(_token1).balanceOf(address(this));\n        }\n        uint256 amount0In = _balance0 > _reserve0 - amount0Out\n            ? _balance0 - (_reserve0 - amount0Out)\n            : 0;\n        uint256 amount1In = _balance1 > _reserve1 - amount1Out\n            ? _balance1 - (_reserve1 - amount1Out)\n            : 0;\n        require(amount0In > 0 || amount1In > 0, \"IIA\"); // Pair: INSUFFICIENT_INPUT_AMOUNT\n        {\n            // scope for reserve{0,1}Adjusted, avoids stack too deep errors\n            (address _token0, address _token1) = (token0, token1);\n            if (amount0In > 0)\n                _update0(\n                    (amount0In * PairFactory(factory).getFee(stable)) / 10000\n                ); // accrue fees for token0 and move them out of pool\n            if (amount1In > 0)\n                _update1(\n                    (amount1In * PairFactory(factory).getFee(stable)) / 10000\n                ); // accrue fees for token1 and move them out of pool\n            _balance0 = IERC20(_token0).balanceOf(address(this)); // since we removed tokens, we need to reconfirm balances, can also simply use previous balance - amountIn/ 10000, but doing balanceOf again as safety check\n            _balance1 = IERC20(_token1).balanceOf(address(this));\n            // The curve, either x3y+y3x for stable pools, or x*y for volatile pools\n            require(_k(_balance0, _balance1) >= _k(_reserve0, _reserve1), \"K\"); // Pair: K\n        }\n\n        _update(_balance0, _balance1, _reserve0, _reserve1);\n        emit Swap(msg.sender, amount0In, amount1In, amount0Out, amount1Out, to);\n    }\n\n    // force balances to match reserves\n    function skim(address to) external lock {\n        (address _token0, address _token1) = (token0, token1);\n        _safeTransfer(\n            _token0,\n            to,\n            IERC20(_token0).balanceOf(address(this)) - (reserve0)\n        );\n        _safeTransfer(\n            _token1,\n            to,\n            IERC20(_token1).balanceOf(address(this)) - (reserve1)\n        );\n    }\n\n    // force reserves to match balances\n    function sync() external lock {\n        _update(\n            IERC20(token0).balanceOf(address(this)),\n            IERC20(token1).balanceOf(address(this)),\n            reserve0,\n            reserve1\n        );\n    }\n\n    function _f(uint256 x0, uint256 y) internal pure returns (uint256) {\n        return\n            (x0 * ((((y * y) / 1e18) * y) / 1e18)) /\n            1e18 +\n            (((((x0 * x0) / 1e18) * x0) / 1e18) * y) /\n            1e18;\n    }\n\n    function _d(uint256 x0, uint256 y) internal pure returns (uint256) {\n        return\n            (3 * x0 * ((y * y) / 1e18)) /\n            1e18 +\n            ((((x0 * x0) / 1e18) * x0) / 1e18);\n    }\n\n    function _get_y(\n        uint256 x0,\n        uint256 xy,\n        uint256 y\n    ) internal pure returns (uint256) {\n        for (uint256 i = 0; i < 255; i++) {\n            uint256 y_prev = y;\n            uint256 k = _f(x0, y);\n            if (k < xy) {\n                uint256 dy = ((xy - k) * 1e18) / _d(x0, y);\n                y = y + dy;\n            } else {\n                uint256 dy = ((k - xy) * 1e18) / _d(x0, y);\n                y = y - dy;\n            }\n            if (y > y_prev) {\n                if (y - y_prev <= 1) {\n                    return y;\n                }\n            } else {\n                if (y_prev - y <= 1) {\n                    return y;\n                }\n            }\n        }\n        return y;\n    }\n\n    function getAmountOut(uint256 amountIn, address tokenIn)\n        external\n        view\n        returns (uint256)\n    {\n        (uint256 _reserve0, uint256 _reserve1) = (reserve0, reserve1);\n        amountIn -= (amountIn * PairFactory(factory).getFee(stable)) / 10000; // remove fee from amount received\n        return _getAmountOut(amountIn, tokenIn, _reserve0, _reserve1);\n    }\n\n    function _getAmountOut(\n        uint256 amountIn,\n        address tokenIn,\n        uint256 _reserve0,\n        uint256 _reserve1\n    ) internal view returns (uint256) {\n        if (stable) {\n            uint256 xy = _k(_reserve0, _reserve1);\n            _reserve0 = (_reserve0 * 1e18) / decimals0;\n            _reserve1 = (_reserve1 * 1e18) / decimals1;\n            (uint256 reserveA, uint256 reserveB) = tokenIn == token0\n                ? (_reserve0, _reserve1)\n                : (_reserve1, _reserve0);\n            amountIn = tokenIn == token0\n                ? (amountIn * 1e18) / decimals0\n                : (amountIn * 1e18) / decimals1;\n            uint256 y = reserveB - _get_y(amountIn + reserveA, xy, reserveB);\n            return (y * (tokenIn == token0 ? decimals1 : decimals0)) / 1e18;\n        } else {\n            (uint256 reserveA, uint256 reserveB) = tokenIn == token0\n                ? (_reserve0, _reserve1)\n                : (_reserve1, _reserve0);\n            return (amountIn * reserveB) / (reserveA + amountIn);\n        }\n    }\n\n    function _k(uint256 x, uint256 y) internal view returns (uint256) {\n        if (stable) {\n            uint256 _x = (x * 1e18) / decimals0;\n            uint256 _y = (y * 1e18) / decimals1;\n            uint256 _a = (_x * _y) / 1e18;\n            uint256 _b = ((_x * _x) / 1e18 + (_y * _y) / 1e18);\n            return (_a * _b) / 1e18; // x3y+y3x >= k\n        } else {\n            return x * y; // xy >= k\n        }\n    }\n\n    function _mint(address dst, uint256 amount) internal {\n        _updateFor(dst); // balances must be updated on mint/burn/transfer\n        totalSupply += amount;\n        balanceOf[dst] += amount;\n        emit Transfer(address(0), dst, amount);\n    }\n\n    function _burn(address dst, uint256 amount) internal {\n        _updateFor(dst);\n        totalSupply -= amount;\n        balanceOf[dst] -= amount;\n        emit Transfer(dst, address(0), amount);\n    }\n\n    function approve(address spender, uint256 amount) external returns (bool) {\n        allowance[msg.sender][spender] = amount;\n\n        emit Approval(msg.sender, spender, amount);\n        return true;\n    }\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external {\n        require(deadline >= block.timestamp, \"Pair: EXPIRED\");\n        DOMAIN_SEPARATOR = keccak256(\n            abi.encode(\n                keccak256(\n                    \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\n                ),\n                keccak256(bytes(name)),\n                keccak256(bytes(\"1\")),\n                block.chainid,\n                address(this)\n            )\n        );\n        bytes32 digest = keccak256(\n            abi.encodePacked(\n                \"\\x19\\x01\",\n                DOMAIN_SEPARATOR,\n                keccak256(\n                    abi.encode(\n                        PERMIT_TYPEHASH,\n                        owner,\n                        spender,\n                        value,\n                        nonces[owner]++,\n                        deadline\n                    )\n                )\n            )\n        );\n        address recoveredAddress = ecrecover(digest, v, r, s);\n        require(\n            recoveredAddress != address(0) && recoveredAddress == owner,\n            \"Pair: INVALID_SIGNATURE\"\n        );\n        allowance[owner][spender] = value;\n\n        emit Approval(owner, spender, value);\n    }\n\n    function transfer(address dst, uint256 amount) external returns (bool) {\n        _transferTokens(msg.sender, dst, amount);\n        return true;\n    }\n\n    function transferFrom(\n        address src,\n        address dst,\n        uint256 amount\n    ) external returns (bool) {\n        address spender = msg.sender;\n        uint256 spenderAllowance = allowance[src][spender];\n\n        if (spender != src && spenderAllowance != type(uint256).max) {\n            uint256 newAllowance = spenderAllowance - amount;\n            allowance[src][spender] = newAllowance;\n\n            emit Approval(src, spender, newAllowance);\n        }\n\n        _transferTokens(src, dst, amount);\n        return true;\n    }\n\n    function _transferTokens(\n        address src,\n        address dst,\n        uint256 amount\n    ) internal {\n        _updateFor(src); // update fee position for src\n        _updateFor(dst); // update fee position for dst\n\n        balanceOf[src] -= amount;\n        balanceOf[dst] += amount;\n\n        emit Transfer(src, dst, amount);\n    }\n\n    function _safeTransfer(\n        address token,\n        address to,\n        uint256 value\n    ) internal {\n        require(token.code.length > 0);\n        (bool success, bytes memory data) = token.call(\n            abi.encodeWithSelector(IERC20.transfer.selector, to, value)\n        );\n        require(success && (data.length == 0 || abi.decode(data, (bool))));\n    }\n}\n","keccak256":"0x4f508747645f4480e0b0f23d952fa9b82af1d9bc60b15b8cd1f542ee136043d1","license":"MIT"},"contracts/PairFees.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport 'contracts/interfaces/IERC20.sol';\n\n// Pair Fees contract is used as a 1:1 pair relationship to split out fees, this ensures that the curve does not need to be modified for LP shares\ncontract PairFees {\n\n    address internal immutable pair; // The pair it is bonded to\n    address internal immutable token0; // token0 of pair, saved localy and statically for gas optimization\n    address internal immutable token1; // Token1 of pair, saved localy and statically for gas optimization\n\n    constructor(address _token0, address _token1) {\n        pair = msg.sender;\n        token0 = _token0;\n        token1 = _token1;\n    }\n\n    function _safeTransfer(address token,address to,uint256 value) internal {\n        require(token.code.length > 0);\n        (bool success, bytes memory data) =\n        token.call(abi.encodeWithSelector(IERC20.transfer.selector, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))));\n    }\n\n    // Allow the pair to transfer fees to users\n    function claimFeesFor(address recipient, uint amount0, uint amount1) external {\n        require(msg.sender == pair);\n        if (amount0 > 0) _safeTransfer(token0, recipient, amount0);\n        if (amount1 > 0) _safeTransfer(token1, recipient, amount1);\n    }\n\n}\n","keccak256":"0xb772e192bab353f8642e89a95ef4ef0255d1caef08444101d7fe34469c1000ca","license":"MIT"},"contracts/factories/PairFactory.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport \"contracts/interfaces/IPairFactory.sol\";\nimport \"contracts/Pair.sol\";\n\ncontract PairFactory is IPairFactory {\n    bool public isPaused;\n    address public pauser;\n    address public pendingPauser;\n\n    uint256 public stableFee;\n    uint256 public volatileFee;\n    uint256 public constant MAX_FEE = 40; // 0.4%\n    address public feeManager;\n    address public pendingFeeManager;\n\n    mapping(address => mapping(address => mapping(bool => address)))\n        public getPair;\n    address[] public allPairs;\n    mapping(address => bool) public isPair; // simplified check if its a pair, given that `stable` flag might not be available in peripherals\n\n    address internal _temp0;\n    address internal _temp1;\n    bool internal _temp;\n\n    event PairCreated(\n        address indexed token0,\n        address indexed token1,\n        bool stable,\n        address pair,\n        uint256\n    );\n\n    constructor() {\n        pauser = msg.sender;\n        isPaused = false;\n        feeManager = msg.sender;\n        stableFee = 3; // 0.03%\n        volatileFee = 25; // 0.25%\n    }\n\n    function allPairsLength() external view returns (uint256) {\n        return allPairs.length;\n    }\n\n    function setPauser(address _pauser) external {\n        require(msg.sender == pauser);\n        pendingPauser = _pauser;\n    }\n\n    function acceptPauser() external {\n        require(msg.sender == pendingPauser);\n        pauser = pendingPauser;\n    }\n\n    function setPause(bool _state) external {\n        require(msg.sender == pauser);\n        isPaused = _state;\n    }\n\n    function setFeeManager(address _feeManager) external {\n        require(msg.sender == feeManager, \"not fee manager\");\n        pendingFeeManager = _feeManager;\n    }\n\n    function acceptFeeManager() external {\n        require(msg.sender == pendingFeeManager, \"not pending fee manager\");\n        feeManager = pendingFeeManager;\n    }\n\n    function setFee(bool _stable, uint256 _fee) external {\n        require(msg.sender == feeManager, \"not fee manager\");\n        require(_fee <= MAX_FEE, \"fee too high\");\n        require(_fee != 0, \"fee must be nonzero\");\n        if (_stable) {\n            stableFee = _fee;\n        } else {\n            volatileFee = _fee;\n        }\n    }\n\n    function getFee(bool _stable) public view returns (uint256) {\n        return _stable ? stableFee : volatileFee;\n    }\n\n    function pairCodeHash() external pure returns (bytes32) {\n        return keccak256(type(Pair).creationCode);\n    }\n\n    function getInitializable()\n        external\n        view\n        returns (\n            address,\n            address,\n            bool\n        )\n    {\n        return (_temp0, _temp1, _temp);\n    }\n\n    function createPair(\n        address tokenA,\n        address tokenB,\n        bool stable\n    ) external returns (address pair) {\n        require(tokenA != tokenB, \"IA\"); // Pair: IDENTICAL_ADDRESSES\n        (address token0, address token1) = tokenA < tokenB\n            ? (tokenA, tokenB)\n            : (tokenB, tokenA);\n        require(token0 != address(0), \"ZA\"); // Pair: ZERO_ADDRESS\n        require(getPair[token0][token1][stable] == address(0), \"PE\"); // Pair: PAIR_EXISTS - single check is sufficient\n        bytes32 salt = keccak256(abi.encodePacked(token0, token1, stable)); // notice salt includes stable as well, 3 parameters\n        (_temp0, _temp1, _temp) = (token0, token1, stable);\n        pair = address(new Pair{salt: salt}());\n        getPair[token0][token1][stable] = pair;\n        getPair[token1][token0][stable] = pair; // populate mapping in the reverse direction\n        allPairs.push(pair);\n        isPair[pair] = true;\n        emit PairCreated(token0, token1, stable, pair, allPairs.length);\n    }\n}\n","keccak256":"0xe4e40f443065445427ca09878adf895cf950308a8fead27c9112083558f16e38","license":"MIT"},"contracts/interfaces/IERC20.sol":{"content":"pragma solidity 0.8.13;\n\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n    function transfer(address recipient, uint amount) external returns (bool);\n    function decimals() external view returns (uint8);\n    function symbol() external view returns (string memory);\n    function balanceOf(address) external view returns (uint);\n    function transferFrom(address sender, address recipient, uint amount) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint);\n    function approve(address spender, uint value) external returns (bool);\n\n    event Transfer(address indexed from, address indexed to, uint value);\n    event Approval(address indexed owner, address indexed spender, uint value);\n}\n","keccak256":"0x892b167ec5245b43ccdfc68d20e8ca12d05725fb6c11ec5ddf6bf77ed0c93c32"},"contracts/interfaces/IPair.sol":{"content":"pragma solidity 0.8.13;\n\ninterface IPair {\n    function metadata() external view returns (uint dec0, uint dec1, uint r0, uint r1, bool st, address t0, address t1);\n    function claimFees() external returns (uint, uint);\n    function tokens() external returns (address, address);\n    function transferFrom(address src, address dst, uint amount) external returns (bool);\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function mint(address to) external returns (uint liquidity);\n    function getReserves() external view returns (uint _reserve0, uint _reserve1, uint _blockTimestampLast);\n    function getAmountOut(uint, address) external view returns (uint);\n}\n","keccak256":"0x796005a0babe921334bacab4a90a551bc7f2ddfb030350a6ba590a9d8440daee"},"contracts/interfaces/IPairCallee.sol":{"content":"pragma solidity 0.8.13;\n\ninterface IPairCallee {\n    function hook(address sender, uint amount0, uint amount1, bytes calldata data) external;\n}\n","keccak256":"0x3ac2de2c7a08bf59fd1006e4d108b247916369de15fbd048b72ca2b7814023ca"},"contracts/interfaces/IPairFactory.sol":{"content":"pragma solidity 0.8.13;\n\ninterface IPairFactory {\n    function allPairsLength() external view returns (uint);\n    function isPair(address pair) external view returns (bool);\n    function pairCodeHash() external pure returns (bytes32);\n    function getPair(address tokenA, address token, bool stable) external view returns (address);\n    function createPair(address tokenA, address tokenB, bool stable) external returns (address pair);\n}\n","keccak256":"0x6a1b9f617020d6a2e0f8cadd51288f5000b0e0dae938a84dc5c977c88c849738"},"contracts/libraries/Math.sol":{"content":"pragma solidity 0.8.13;\n\n// this causes issue with forge test as there is already a Math.sol in the forge repo\nlibrary MathDunks {\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a >= b ? a : b;\n    }\n\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    function sqrt(uint256 y) internal pure returns (uint256 z) {\n        if (y > 3) {\n            z = y;\n            uint256 x = y / 2 + 1;\n            while (x < z) {\n                z = x;\n                x = (y / x + x) / 2;\n            }\n        } else if (y != 0) {\n            z = 1;\n        }\n    }\n\n    function cbrt(uint256 n) internal pure returns (uint256) {\n        unchecked {\n            uint256 x = 0;\n            for (uint256 y = 1 << 255; y > 0; y >>= 3) {\n                x <<= 1;\n                uint256 z = 3 * x * (x + 1) + 1;\n                if (n / y >= z) {\n                    n -= y * z;\n                    x += 1;\n                }\n            }\n            return x;\n        }\n    }\n}\n","keccak256":"0xd7894a4b5d2afa5680c6a4c3de7dcb26ccd7dcf4339ca9d4478677cd5dc32be9"}},"version":1}